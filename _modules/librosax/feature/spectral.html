<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html"><link rel="search" title="Search" href="../../../search.html">

    <!-- Generated with Sphinx 9.0.4 and Furo 2025.12.19 -->
        <title>librosax.feature.spectral - Librosax Documentation, v0.1.3</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=d111a655" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?v=7bdb33bb" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?v=8dab3a3b" />
    
    


<style>
  body {
    --color-code-background: #f2f2f2;
  --color-code-foreground: #1e1e1e;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">Librosax Documentation, v0.1.3</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  <span class="sidebar-brand-text">Librosax Documentation, v0.1.3</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scope.html">Scope and Design Philosophy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
</ul>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../librosax.html">Librosax</a><input aria-label="Toggle navigation of Librosax" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.stft.html">librosax.stft</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.istft.html">librosax.istft</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.amplitude_to_db.html">librosax.amplitude_to_db</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.power_to_db.html">librosax.power_to_db</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.fft_frequencies.html">librosax.fft_frequencies</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../_autosummary/librosax.feature.html">librosax.feature</a><input aria-label="Toggle navigation of librosax.feature" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.feature.spectral_centroid.html">librosax.feature.spectral_centroid</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.feature.spectral_bandwidth.html">librosax.feature.spectral_bandwidth</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.feature.spectral_rolloff.html">librosax.feature.spectral_rolloff</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.feature.spectral_flatness.html">librosax.feature.spectral_flatness</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.feature.spectral_contrast.html">librosax.feature.spectral_contrast</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.feature.rms.html">librosax.feature.rms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.feature.zero_crossing_rate.html">librosax.feature.zero_crossing_rate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.feature.melspectrogram.html">librosax.feature.melspectrogram</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.feature.mfcc.html">librosax.feature.mfcc</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.feature.chroma_stft.html">librosax.feature.chroma_stft</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.feature.chroma_cqt.html">librosax.feature.chroma_cqt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.feature.chroma_filter.html">librosax.feature.chroma_filter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.feature.cqt.html">librosax.feature.cqt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.feature.cqt2010.html">librosax.feature.cqt2010</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.feature.cqt_frequencies.html">librosax.feature.cqt_frequencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.feature.tonnetz.html">librosax.feature.tonnetz</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.feature.hz_to_octs.html">librosax.feature.hz_to_octs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.feature.note_to_hz.html">librosax.feature.note_to_hz</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../_autosummary/librosax.layers.html">librosax.layers</a><input aria-label="Toggle navigation of librosax.layers" class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.layers.Spectrogram.html">librosax.layers.Spectrogram</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.layers.LogMelFilterBank.html">librosax.layers.LogMelFilterBank</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.layers.MFCC.html">librosax.layers.MFCC</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.layers.DropStripes.html">librosax.layers.DropStripes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../_autosummary/generated/librosax.layers.SpecAugmentation.html">librosax.layers.SpecAugmentation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../feature.html">Feature extraction</a><input aria-label="Toggle navigation of Feature extraction" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.feature.spectral_centroid.html">librosax.feature.spectral_centroid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.feature.spectral_bandwidth.html">librosax.feature.spectral_bandwidth</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.feature.spectral_rolloff.html">librosax.feature.spectral_rolloff</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.feature.spectral_flatness.html">librosax.feature.spectral_flatness</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.feature.spectral_contrast.html">librosax.feature.spectral_contrast</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.feature.rms.html">librosax.feature.rms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.feature.zero_crossing_rate.html">librosax.feature.zero_crossing_rate</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.feature.melspectrogram.html">librosax.feature.melspectrogram</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.feature.mfcc.html">librosax.feature.mfcc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.feature.chroma_stft.html">librosax.feature.chroma_stft</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.feature.chroma_cqt.html">librosax.feature.chroma_cqt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.feature.chroma_filter.html">librosax.feature.chroma_filter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.feature.cqt.html">librosax.feature.cqt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.feature.cqt2010.html">librosax.feature.cqt2010</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.feature.cqt_frequencies.html">librosax.feature.cqt_frequencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.feature.tonnetz.html">librosax.feature.tonnetz</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.feature.hz_to_octs.html">librosax.feature.hz_to_octs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.feature.note_to_hz.html">librosax.feature.note_to_hz</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../layers.html">Neural network layers</a><input aria-label="Toggle navigation of Neural network layers" class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.layers.Spectrogram.html">librosax.layers.Spectrogram</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.layers.LogMelFilterBank.html">librosax.layers.LogMelFilterBank</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.layers.MFCC.html">librosax.layers.MFCC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.layers.DropStripes.html">librosax.layers.DropStripes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/librosax.layers.SpecAugmentation.html">librosax.layers.SpecAugmentation</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <h1>Source code for librosax.feature.spectral</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Callable</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">jax</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">librosa</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">jax</span><span class="w"> </span><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">jnp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">jax.scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">signal</span> <span class="k">as</span> <span class="n">jssignal</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">librosax.core.spectrum</span><span class="w"> </span><span class="kn">import</span> <span class="n">fft_frequencies</span><span class="p">,</span> <span class="n">normalize</span><span class="p">,</span> <span class="n">power_to_db</span><span class="p">,</span> <span class="n">stft</span><span class="p">,</span> <span class="n">_spectrogram</span><span class="p">,</span> <span class="n">_dct_flexible</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">librosax.core.convert</span><span class="w"> </span><span class="kn">import</span> <span class="n">note_to_hz</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">librosax</span><span class="w"> </span><span class="kn">import</span> <span class="n">filters</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">librosax.util.exceptions</span><span class="w"> </span><span class="kn">import</span> <span class="n">ParameterError</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">partial</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;spectral_centroid&quot;</span><span class="p">,</span>
    <span class="s2">&quot;spectral_bandwidth&quot;</span><span class="p">,</span>
    <span class="s2">&quot;spectral_contrast&quot;</span><span class="p">,</span>
    <span class="s2">&quot;spectral_rolloff&quot;</span><span class="p">,</span>
    <span class="s2">&quot;spectral_flatness&quot;</span><span class="p">,</span>
    <span class="s2">&quot;poly_features&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rms&quot;</span><span class="p">,</span>
    <span class="s2">&quot;zero_crossing_rate&quot;</span><span class="p">,</span>
    <span class="s2">&quot;chroma_stft&quot;</span><span class="p">,</span>
    <span class="s2">&quot;chroma_cqt&quot;</span><span class="p">,</span>
    <span class="s2">&quot;chroma_vqt&quot;</span><span class="p">,</span>
    <span class="s2">&quot;chroma_cens&quot;</span><span class="p">,</span>
    <span class="s2">&quot;melspectrogram&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mfcc&quot;</span><span class="p">,</span>
    <span class="s2">&quot;tonnetz&quot;</span><span class="p">,</span>
    <span class="s2">&quot;cqt&quot;</span><span class="p">,</span>
    <span class="s2">&quot;cqt2010&quot;</span><span class="p">,</span>
    <span class="s2">&quot;cqt_frequencies&quot;</span><span class="p">,</span>
<span class="p">]</span>


<div class="viewcode-block" id="spectral_centroid">
<a class="viewcode-back" href="../../../generated/librosax.feature.spectral_centroid.html#librosax.feature.spectral_centroid">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">spectral_centroid</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">22050</span><span class="p">,</span>
    <span class="n">S</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
    <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">win_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the spectral centroid.</span>

<span class="sd">    Each frame of a magnitude spectrogram is normalized and treated as a</span>
<span class="sd">    distribution over frequency bins, from which the mean (centroid) is</span>
<span class="sd">    extracted per frame.</span>

<span class="sd">    More precisely, the centroid at frame t is defined as:</span>
<span class="sd">        centroid[t] = sum_k S[k, t] * freq[k] / (sum_j S[j, t])</span>

<span class="sd">    where S is a magnitude spectrogram, and freq is the array of frequencies</span>
<span class="sd">    (e.g., FFT frequencies in Hz) of the rows of S.</span>

<span class="sd">    Users should ensure S is real-valued and non-negative.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: Audio time series. The last axis must be time.</span>

<span class="sd">            - ``(T,)`` - single waveform</span>
<span class="sd">            - ``(B, T)`` - batch of waveforms</span>

<span class="sd">        sr: Audio sampling rate</span>
<span class="sd">        S: (optional) Pre-computed spectrogram magnitude with shape ``(..., F, N)``</span>
<span class="sd">        n_fft: FFT window size</span>
<span class="sd">        hop_length: Hop length for STFT</span>
<span class="sd">        freq: Center frequencies for spectrogram bins. If None, FFT bin center</span>
<span class="sd">            frequencies are used.</span>
<span class="sd">        win_length: Window length</span>
<span class="sd">        window: Window function</span>
<span class="sd">        center: If True, pad the signal</span>
<span class="sd">        pad_mode: Padding mode</span>

<span class="sd">    Returns:</span>
<span class="sd">        Spectral centroid frequencies with shape ``(..., 1, N)`` where N is the</span>
<span class="sd">        number of frames. The frequency axis is reduced to size 1.</span>

<span class="sd">        - ``(T,)`` → ``(1, N)``</span>
<span class="sd">        - ``(B, T)`` → ``(B, 1, N)``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Compute the center frequencies of each bin</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="c1"># Ensure freq has the right shape for broadcasting</span>
    <span class="k">if</span> <span class="n">freq</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Reshape freq to match S dimensions</span>
        <span class="c1"># S has shape (..., frequency, time)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">freq</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

    <span class="c1"># Column-normalize S</span>
    <span class="c1"># norm=1 means L1 norm (sum of absolute values)</span>
    <span class="n">centroid</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">freq</span> <span class="o">*</span> <span class="n">normalize</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">centroid</span></div>



<div class="viewcode-block" id="spectral_bandwidth">
<a class="viewcode-back" href="../../../generated/librosax.feature.spectral_bandwidth.html#librosax.feature.spectral_bandwidth">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">spectral_bandwidth</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">22050</span><span class="p">,</span>
    <span class="n">S</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
    <span class="n">win_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">centroid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">norm</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute p&#39;th-order spectral bandwidth.</span>

<span class="sd">    The spectral bandwidth at frame t is computed by:</span>
<span class="sd">        (sum_k S[k, t] * (freq[k, t] - centroid[t])**p)**(1/p)</span>

<span class="sd">    Users should ensure S is real-valued and non-negative.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: Audio time series. The last axis must be time.</span>

<span class="sd">            - ``(T,)`` - single waveform</span>
<span class="sd">            - ``(B, T)`` - batch of waveforms</span>

<span class="sd">        sr: Audio sampling rate</span>
<span class="sd">        S: (optional) Pre-computed spectrogram magnitude with shape ``(..., F, N)``</span>
<span class="sd">        n_fft: FFT window size</span>
<span class="sd">        hop_length: Hop length for STFT</span>
<span class="sd">        win_length: Window length</span>
<span class="sd">        window: Window function</span>
<span class="sd">        center: If True, pad the signal</span>
<span class="sd">        pad_mode: Padding mode</span>
<span class="sd">        freq: Center frequencies for spectrogram bins. If None, FFT bin center</span>
<span class="sd">            frequencies are used.</span>
<span class="sd">        centroid: Pre-computed centroid frequencies</span>
<span class="sd">        norm: Normalize per-frame spectral energy (sum to one)</span>
<span class="sd">        p: Power to raise deviation from spectral centroid</span>

<span class="sd">    Returns:</span>
<span class="sd">        Frequency bandwidth with shape ``(..., 1, N)``.</span>

<span class="sd">        - ``(T,)`` → ``(1, N)``</span>
<span class="sd">        - ``(B, T)`` → ``(B, 1, N)``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># If we don&#39;t have a centroid provided, compute it</span>
    <span class="k">if</span> <span class="n">centroid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">spectral_centroid</span><span class="p">(</span>
            <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span>
        <span class="p">)</span>

    <span class="c1"># Compute the center frequencies of each bin</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="c1"># Calculate deviation from centroid</span>
    <span class="k">if</span> <span class="n">freq</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Use outer subtraction</span>
        <span class="c1"># centroid has shape (..., 1, time), extract (..., time)</span>
        <span class="n">centroid_squeezed</span> <span class="o">=</span> <span class="n">centroid</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># subtract.outer gives shape (time, freq), need to swap axes</span>
        <span class="n">deviation</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">subtract</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">centroid_squeezed</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">deviation</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">freq</span> <span class="o">-</span> <span class="n">centroid</span><span class="p">)</span>

    <span class="c1"># Column-normalize S if requested</span>
    <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Compute bandwidth</span>
    <span class="n">bw</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">S</span> <span class="o">*</span> <span class="n">deviation</span><span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">p</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">bw</span></div>



<div class="viewcode-block" id="spectral_rolloff">
<a class="viewcode-back" href="../../../generated/librosax.feature.spectral_rolloff.html#librosax.feature.spectral_rolloff">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">spectral_rolloff</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">22050</span><span class="p">,</span>
    <span class="n">S</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
    <span class="n">win_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">roll_percent</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.85</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute roll-off frequency.</span>

<span class="sd">    The roll-off frequency is defined for each frame as the center frequency</span>
<span class="sd">    for a spectrogram bin such that at least roll_percent (0.85 by default)</span>
<span class="sd">    of the energy of the spectrum in this frame is contained in this bin and</span>
<span class="sd">    the bins below. Users should ensure S is real-valued and non-negative.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: Audio time series. The last axis must be time.</span>

<span class="sd">            - ``(T,)`` - single waveform</span>
<span class="sd">            - ``(B, T)`` - batch of waveforms</span>

<span class="sd">        sr: Audio sampling rate</span>
<span class="sd">        S: (optional) Pre-computed spectrogram magnitude with shape ``(..., F, N)``</span>
<span class="sd">        n_fft: FFT window size</span>
<span class="sd">        hop_length: Hop length for STFT</span>
<span class="sd">        win_length: Window length</span>
<span class="sd">        window: Window function</span>
<span class="sd">        center: If True, pad the signal</span>
<span class="sd">        pad_mode: Padding mode</span>
<span class="sd">        freq: Center frequencies for spectrogram bins. If None, FFT bin center</span>
<span class="sd">            frequencies are used. Assumed to be sorted in increasing order.</span>
<span class="sd">        roll_percent: Roll-off percentage (0 &lt; roll_percent &lt; 1)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Roll-off frequency with shape ``(..., 1, N)``.</span>

<span class="sd">        - ``(T,)`` → ``(1, N)``</span>
<span class="sd">        - ``(B, T)`` → ``(B, 1, N)``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mf">0.0</span> <span class="o">&lt;</span> <span class="n">roll_percent</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;roll_percent must lie in the range (0, 1)&quot;</span><span class="p">)</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Compute the center frequencies of each bin</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="c1"># Make sure that frequency can be broadcast</span>
    <span class="k">if</span> <span class="n">freq</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Reshape freq to match S dimensions</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">freq</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

    <span class="c1"># Compute cumulative energy</span>
    <span class="n">total_energy</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Get threshold energy</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">roll_percent</span> <span class="o">*</span> <span class="n">total_energy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Reshape threshold for broadcasting</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Find where cumulative energy exceeds threshold</span>
    <span class="c1"># Use where to set values below threshold to nan</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">total_energy</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Get the minimum frequency that meets the threshold</span>
    <span class="n">rolloff</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">ind</span> <span class="o">*</span> <span class="n">freq</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rolloff</span></div>



<div class="viewcode-block" id="spectral_flatness">
<a class="viewcode-back" href="../../../generated/librosax.feature.spectral_flatness.html#librosax.feature.spectral_flatness">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">spectral_flatness</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">S</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
    <span class="n">win_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">amin</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">,</span>
    <span class="n">power</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute spectral flatness.</span>

<span class="sd">    Spectral flatness (or tonality coefficient) is a measure to quantify</span>
<span class="sd">    how much noise-like a sound is, as opposed to being tone-like.</span>
<span class="sd">    A high spectral flatness (closer to 1.0) indicates the spectrum is</span>
<span class="sd">    similar to white noise. Users should ensure S is real-valued and</span>
<span class="sd">    non-negative.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: Audio time series. The last axis must be time.</span>

<span class="sd">            - ``(T,)`` - single waveform</span>
<span class="sd">            - ``(B, T)`` - batch of waveforms</span>

<span class="sd">        S: (optional) Pre-computed spectrogram magnitude with shape ``(..., F, N)``</span>
<span class="sd">        n_fft: FFT window size</span>
<span class="sd">        hop_length: Hop length for STFT</span>
<span class="sd">        win_length: Window length</span>
<span class="sd">        window: Window function</span>
<span class="sd">        center: If True, pad the signal</span>
<span class="sd">        pad_mode: Padding mode</span>
<span class="sd">        amin: Minimum threshold for S (added noise floor for numerical stability)</span>
<span class="sd">        power: Exponent for the magnitude spectrogram (e.g., 1 for energy, 2 for power)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Spectral flatness with shape ``(..., 1, N)``.</span>

<span class="sd">        - ``(T,)`` → ``(1, N)``</span>
<span class="sd">        - ``(B, T)`` → ``(B, 1, N)``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">amin</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;amin must be strictly positive&quot;</span><span class="p">)</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Apply power and threshold</span>
    <span class="n">S_thresh</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">amin</span><span class="p">,</span> <span class="n">S</span><span class="o">**</span><span class="n">power</span><span class="p">)</span>

    <span class="c1"># Compute geometric mean (using log for numerical stability)</span>
    <span class="n">gmean</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">S_thresh</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

    <span class="c1"># Compute arithmetic mean</span>
    <span class="n">amean</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">S_thresh</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Spectral flatness is the ratio of geometric to arithmetic mean</span>
    <span class="n">flatness</span> <span class="o">=</span> <span class="n">gmean</span> <span class="o">/</span> <span class="n">amean</span>

    <span class="k">return</span> <span class="n">flatness</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">frame</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">frame_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Slice a data array into overlapping frames.</span>

<span class="sd">    This implementation uses JAX operations to create a sliding window view.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: Input array to frame</span>
<span class="sd">        frame_length: Length of each frame</span>
<span class="sd">        hop_length: Number of steps to advance between frames</span>
<span class="sd">        axis: The axis along which to frame (default: -1)</span>

<span class="sd">    Returns:</span>
<span class="sd">        jnp.ndarray: Framed view of the input array with an additional dimension.</span>
<span class="sd">        The output shape has frames as a new dimension after the framed axis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">+</span> <span class="n">axis</span>

    <span class="c1"># Get the shape and create index arrays</span>
    <span class="n">n_frames</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">frame_length</span><span class="p">)</span> <span class="o">//</span> <span class="n">hop_length</span>

    <span class="c1"># For 1D input, we can use a simpler approach</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">frame_length</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_frames</span><span class="p">)</span> <span class="o">*</span> <span class="n">hop_length</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="c1"># Shape is now (n_frames, frame_length), need to swap to (frame_length, n_frames)</span>
        <span class="k">return</span> <span class="n">frames</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Use JAX&#39;s dynamic_slice with vmap for multidimensional arrays</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_frame</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="n">start_indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">start_indices</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">hop_length</span>
        <span class="n">slice_sizes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">slice_sizes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">frame_length</span>
        <span class="k">return</span> <span class="n">jax</span><span class="o">.</span><span class="n">lax</span><span class="o">.</span><span class="n">dynamic_slice</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">start_indices</span><span class="p">,</span> <span class="n">slice_sizes</span><span class="p">)</span>

    <span class="n">frames</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">get_frame</span><span class="p">)(</span><span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_frames</span><span class="p">))</span>

    <span class="c1"># Rearrange dimensions to match librosa&#39;s output</span>
    <span class="c1"># frames currently has shape (n_frames, ...), we need (..., frame_length, n_frames)</span>
    <span class="c1"># Move the frame dimension to be the last dimension</span>
    <span class="n">perm</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">frames</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">frames</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">frames</span>


<span class="k">def</span><span class="w"> </span><span class="nf">abs2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">dtype</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the squared magnitude of a real or complex array.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: Input array (real or complex)</span>
<span class="sd">        dtype: Optional output data type</span>

<span class="sd">    Returns:</span>
<span class="sd">        jnp.ndarray: Squared magnitude</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">jnp</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="rms">
<a class="viewcode-back" href="../../../generated/librosax.feature.rms.html#librosax.feature.rms">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rms</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">S</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">frame_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
    <span class="n">center</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute root-mean-square (RMS) value for each frame.</span>

<span class="sd">    Computing the RMS value from audio samples is faster as it doesn&#39;t require</span>
<span class="sd">    a STFT calculation. However, using a spectrogram will give a more accurate</span>
<span class="sd">    representation of energy over time because its frames can be windowed.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: (optional) Audio time series. The last axis must be time.</span>

<span class="sd">            - ``(T,)`` - single waveform</span>
<span class="sd">            - ``(B, T)`` - batch of waveforms</span>

<span class="sd">        S: (optional) Spectrogram magnitude with shape ``(..., F, N)``</span>
<span class="sd">        frame_length: Length of analysis frame (in samples) for energy calculation</span>
<span class="sd">        hop_length: Hop length for STFT</span>
<span class="sd">        center: If True and operating on time-domain input (y), pad the signal</span>
<span class="sd">            by frame_length//2 on either side. Has no effect on spectrogram input.</span>
<span class="sd">        pad_mode: Padding mode for centered analysis</span>
<span class="sd">        dtype: Data type of the output array</span>

<span class="sd">    Returns:</span>
<span class="sd">        RMS value with shape ``(..., 1, N)``.</span>

<span class="sd">        - ``(T,)`` → ``(1, N)``</span>
<span class="sd">        - ``(B, T)`` → ``(B, 1, N)``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
            <span class="c1"># Pad the signal</span>
            <span class="n">pad_width</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>
            <span class="n">pad_width</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">frame_length</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">frame_length</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>

        <span class="c1"># Frame the signal</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">frame</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">frame_length</span><span class="o">=</span><span class="n">frame_length</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>

        <span class="c1"># Calculate power</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">abs2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">S</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Note: Runtime checks are not compatible with JIT compilation</span>
        <span class="c1"># Users should ensure S.shape[-2] == frame_length // 2 + 1</span>
        <span class="k">if</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">frame_length</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Since S.shape[-2] is </span><span class="si">{</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;frame_length is expected to be </span><span class="si">{</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="si">}</span><span class="s2"> or </span><span class="si">{</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;found </span><span class="si">{</span><span class="n">frame_length</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Power spectrogram</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">abs2</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Adjust the DC and sr/2 component</span>
        <span class="c1"># Create a copy to modify</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">frame_length</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="c1"># Calculate power</span>
        <span class="n">power</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">/</span> <span class="n">frame_length</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;Either y or S must be input.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">power</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">zero_crossings</span><span class="p">(</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">,</span>
    <span class="n">ref_magnitude</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">pad</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">zero_pos</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find zero-crossings of a signal.</span>

<span class="sd">    Zero-crossings are indices i such that sign(y[i]) != sign(y[i+1]).</span>

<span class="sd">    Args:</span>
<span class="sd">        y: Input array</span>
<span class="sd">        threshold: If non-zero, values where -threshold &lt;= y &lt;= threshold are</span>
<span class="sd">            clipped to 0.</span>
<span class="sd">        ref_magnitude: If numeric, the threshold is scaled relative to ref_magnitude.</span>
<span class="sd">            If callable, the threshold is scaled relative to ref_magnitude(abs(y)).</span>
<span class="sd">        pad: If True, then y[0] is considered a valid zero-crossing.</span>
<span class="sd">        zero_pos: If True then the value 0 is interpreted as having positive sign.</span>
<span class="sd">            If False, then 0, -1, and +1 all have distinct signs.</span>
<span class="sd">        axis: Axis along which to compute zero-crossings.</span>

<span class="sd">    Returns:</span>
<span class="sd">        jnp.ndarray: Boolean array indicating zero-crossings</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">ref_magnitude</span><span class="p">):</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span> <span class="o">*</span> <span class="n">ref_magnitude</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">ref_magnitude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span> <span class="o">*</span> <span class="n">ref_magnitude</span>

    <span class="c1"># Apply threshold</span>
    <span class="n">y_thresh</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="c1"># Get sign of consecutive elements</span>
    <span class="k">if</span> <span class="n">zero_pos</span><span class="p">:</span>
        <span class="c1"># Use signbit for zero_pos mode (0 has positive sign)</span>
        <span class="n">signs</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">signbit</span><span class="p">(</span><span class="n">y_thresh</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Use sign for regular mode</span>
        <span class="n">signs</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">y_thresh</span><span class="p">)</span>

    <span class="c1"># Compute differences along the specified axis</span>
    <span class="c1"># Zero crossing occurs when signs differ</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">signs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="c1"># Create output array with proper shape</span>
    <span class="n">z_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">z_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">!=</span> <span class="mi">0</span>

    <span class="c1"># Pad to match input shape if requested</span>
    <span class="k">if</span> <span class="n">pad</span><span class="p">:</span>
        <span class="n">pad_width</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>
        <span class="n">pad_width</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Need to pad with False to match shape</span>
        <span class="n">pad_width</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>
        <span class="n">pad_width</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">z</span>


<div class="viewcode-block" id="zero_crossing_rate">
<a class="viewcode-back" href="../../../generated/librosax.feature.zero_crossing_rate.html#librosax.feature.zero_crossing_rate">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">zero_crossing_rate</span><span class="p">(</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">frame_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
    <span class="n">center</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the zero-crossing rate of an audio time series.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: Audio time series. The last axis must be time.</span>

<span class="sd">            - ``(T,)`` - single waveform</span>
<span class="sd">            - ``(B, T)`` - batch of waveforms</span>

<span class="sd">        frame_length: Length of the frame over which to compute zero crossing rates</span>
<span class="sd">        hop_length: Number of samples to advance for each frame</span>
<span class="sd">        center: If True, frames are centered by padding the edges of y.</span>
<span class="sd">            Uses edge-value copies instead of zero-padding.</span>
<span class="sd">        **kwargs: Additional keyword arguments to pass to zero_crossings</span>

<span class="sd">    Returns:</span>
<span class="sd">        Zero crossing rate with shape ``(..., 1, N)``.</span>

<span class="sd">        - ``(T,)`` → ``(1, N)``</span>
<span class="sd">        - ``(B, T)`` → ``(B, 1, N)``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
        <span class="c1"># Pad with edge values</span>
        <span class="n">pad_width</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>
        <span class="n">pad_width</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">frame_length</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">frame_length</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>

    <span class="c1"># Frame the signal</span>
    <span class="n">y_framed</span> <span class="o">=</span> <span class="n">frame</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">frame_length</span><span class="o">=</span><span class="n">frame_length</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>

    <span class="c1"># Set default pad=False for zero_crossings within frames</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;pad&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>

    <span class="c1"># Compute zero crossings for each frame</span>
    <span class="n">crossings</span> <span class="o">=</span> <span class="n">zero_crossings</span><span class="p">(</span><span class="n">y_framed</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># Average over frame dimension</span>
    <span class="n">zcr</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">crossings</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">zcr</span></div>



<div class="viewcode-block" id="spectral_contrast">
<a class="viewcode-back" href="../../../generated/librosax.feature.spectral_contrast.html#librosax.feature.spectral_contrast">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">spectral_contrast</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">22050</span><span class="p">,</span>
    <span class="n">S</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
    <span class="n">win_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">fmin</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">200.0</span><span class="p">,</span>
    <span class="n">n_bands</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
    <span class="n">quantile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.02</span><span class="p">,</span>
    <span class="n">linear</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute spectral contrast.</span>

<span class="sd">    Each frame of a spectrogram S is divided into sub-bands.</span>
<span class="sd">    For each sub-band, the energy contrast is estimated by comparing</span>
<span class="sd">    the mean energy in the top quantile (peak energy) to that of the</span>
<span class="sd">    bottom quantile (valley energy). High contrast values generally</span>
<span class="sd">    correspond to clear, narrow-band signals, while low contrast values</span>
<span class="sd">    correspond to broad-band noise.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: Audio time series. The last axis must be time.</span>

<span class="sd">            - ``(T,)`` - single waveform</span>
<span class="sd">            - ``(B, T)`` - batch of waveforms</span>

<span class="sd">        sr: Audio sampling rate</span>
<span class="sd">        S: (optional) Pre-computed spectrogram magnitude with shape ``(..., F, N)``</span>
<span class="sd">        n_fft: FFT window size</span>
<span class="sd">        hop_length: Hop length for STFT</span>
<span class="sd">        win_length: Window length</span>
<span class="sd">        window: Window function</span>
<span class="sd">        center: If True, pad the signal</span>
<span class="sd">        pad_mode: Padding mode</span>
<span class="sd">        freq: Center frequencies for spectrogram bins. If None, FFT bin center</span>
<span class="sd">            frequencies are used.</span>
<span class="sd">        fmin: Frequency cutoff for the first bin [0, fmin]</span>
<span class="sd">            Subsequent bins will cover [fmin, 2*fmin], [2*fmin, 4*fmin], etc.</span>
<span class="sd">        n_bands: Number of frequency bands</span>
<span class="sd">        quantile: Quantile for determining peaks and valleys</span>
<span class="sd">        linear: If True, return the linear difference of magnitudes: peaks - valleys.</span>
<span class="sd">            If False, return the logarithmic difference: log(peaks) - log(valleys).</span>

<span class="sd">    Returns:</span>
<span class="sd">        Spectral contrast with shape ``(..., n_bands + 1, N)``.</span>

<span class="sd">        - ``(T,)`` → ``(n_bands + 1, N)``</span>
<span class="sd">        - ``(B, T)`` → ``(B, n_bands + 1, N)``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Compute the center frequencies of each bin</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="n">freq</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">freq</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="o">!=</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;freq.shape mismatch: expected (</span><span class="si">{</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">,)&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n_bands</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_bands</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;n_bands must be a positive integer&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="mf">0.0</span> <span class="o">&lt;</span> <span class="n">quantile</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;quantile must lie in the range (0, 1)&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fmin</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;fmin must be a positive number&quot;</span><span class="p">)</span>

    <span class="c1"># Create octave bands</span>
    <span class="n">octa</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_bands</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">octa</span> <span class="o">=</span> <span class="n">octa</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">fmin</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">**</span> <span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_bands</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

    <span class="c1"># Calculate maximum possible quantile index size</span>
    <span class="c1"># The largest band is typically the last one, which can extend to all remaining bins</span>
    <span class="c1"># from the lowest frequency of that band to the Nyquist frequency</span>
    <span class="c1"># In the worst case, this could be nearly all frequency bins</span>
    <span class="n">max_possible_band_size</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># Conservative upper bound</span>
    <span class="c1"># Use Python int() to ensure it&#39;s a static value</span>
    <span class="n">max_quantile_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_possible_band_size</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">quantile</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
    
    <span class="c1"># Process bands using scan for JIT compatibility</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process_band</span><span class="p">(</span><span class="n">carry</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">S</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">octa</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">n_bands</span><span class="p">,</span> <span class="n">quantile</span> <span class="o">=</span> <span class="n">carry</span>
        
        <span class="n">f_low</span> <span class="o">=</span> <span class="n">octa</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">f_high</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">lax</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
            <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n_bands</span><span class="p">,</span>
            <span class="k">lambda</span><span class="p">:</span> <span class="n">octa</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
            <span class="k">lambda</span><span class="p">:</span> <span class="n">sr</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="p">)</span>
        
        <span class="c1"># Create band mask</span>
        <span class="n">band_mask</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freq</span> <span class="o">&gt;=</span> <span class="n">f_low</span><span class="p">,</span> <span class="n">freq</span> <span class="o">&lt;=</span> <span class="n">f_high</span><span class="p">)</span>
        
        <span class="c1"># Find first and last indices</span>
        <span class="c1"># Use cumsum trick to find positions</span>
        <span class="n">cumsum</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">band_mask</span><span class="p">)</span>
        <span class="n">has_true</span> <span class="o">=</span> <span class="n">cumsum</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
        
        <span class="c1"># Find first True (where cumsum goes from 0 to 1)</span>
        <span class="n">first_idx</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">has_true</span><span class="p">,</span>
                             <span class="n">jnp</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">cumsum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span>
                             <span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Find last True</span>
        <span class="n">reverse_cumsum</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">band_mask</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">last_idx</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">has_true</span><span class="p">,</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">band_mask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">jnp</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">reverse_cumsum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span>
                            <span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Adjust boundaries as in librosa</span>
        <span class="c1"># For k &gt; 0, include one bin below</span>
        <span class="n">first_idx</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">lax</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
            <span class="n">jnp</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">first_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span>
            <span class="k">lambda</span><span class="p">:</span> <span class="n">first_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="k">lambda</span><span class="p">:</span> <span class="n">first_idx</span>
        <span class="p">)</span>
        
        <span class="c1"># For the last band, extend to the end</span>
        <span class="n">last_idx</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">lax</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
            <span class="n">k</span> <span class="o">==</span> <span class="n">n_bands</span><span class="p">,</span>
            <span class="k">lambda</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="k">lambda</span><span class="p">:</span> <span class="n">last_idx</span>
        <span class="p">)</span>
        
        <span class="c1"># Update band mask with adjusted boundaries</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freq</span><span class="p">))</span>
        <span class="n">band_mask_adjusted</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">indices</span> <span class="o">&gt;=</span> <span class="n">first_idx</span><span class="p">,</span> <span class="n">indices</span> <span class="o">&lt;=</span> <span class="n">last_idx</span><span class="p">)</span>
        
        <span class="c1"># For non-final bands, exclude the last bin</span>
        <span class="n">band_mask_final</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">lax</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
            <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n_bands</span><span class="p">,</span>
            <span class="k">lambda</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">band_mask_adjusted</span><span class="p">,</span> <span class="n">indices</span> <span class="o">&lt;</span> <span class="n">last_idx</span><span class="p">),</span>
            <span class="k">lambda</span><span class="p">:</span> <span class="n">band_mask_adjusted</span>
        <span class="p">)</span>
        
        <span class="c1"># Count bins for quantile calculation (use original band mask count)</span>
        <span class="n">n_bins_for_quantile</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">band_mask_adjusted</span><span class="p">)</span>
        
        <span class="c1"># Extract sub-band values</span>
        <span class="c1"># Use masking approach</span>
        <span class="n">sub_band_values</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">band_mask_final</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">S</span><span class="p">,</span> <span class="o">-</span><span class="n">jnp</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        
        <span class="c1"># Sort along frequency axis</span>
        <span class="n">sorted_sub</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sub_band_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Find where valid values start (first non-(-inf) value)</span>
        <span class="n">valid_mask</span> <span class="o">=</span> <span class="n">sorted_sub</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">jnp</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">n_valid</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">valid_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Calculate quantile index</span>
        <span class="n">n_idx</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">quantile</span> <span class="o">*</span> <span class="n">n_bins_for_quantile</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># For each time frame, we need to extract bottom n_idx and top n_idx values</span>
        <span class="c1"># max_quantile_size is captured from the outer scope as a static value</span>
        
        <span class="c1"># Create index arrays for gathering</span>
        <span class="n">time_frames</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">frame_indices</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">time_frames</span><span class="p">)</span>
        <span class="n">idx_range</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">max_quantile_size</span><span class="p">)</span>
        
        <span class="c1"># Find first valid index per frame</span>
        <span class="n">first_valid_idx</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">valid_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Valley indices: first n_idx valid values</span>
        <span class="n">valley_indices</span> <span class="o">=</span> <span class="n">first_valid_idx</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">idx_range</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">valley_indices</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">valley_indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sorted_sub</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># Gather valley values</span>
        <span class="n">valley_values</span> <span class="o">=</span> <span class="n">sorted_sub</span><span class="p">[</span><span class="n">valley_indices</span><span class="p">,</span> <span class="n">frame_indices</span><span class="p">]</span>
        <span class="n">valley_mask</span> <span class="o">=</span> <span class="n">idx_range</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">n_idx</span><span class="p">,</span> <span class="n">n_valid</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">valley_values</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">valley_mask</span><span class="p">,</span> <span class="n">valley_values</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">valley</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">valley_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">jnp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">valley_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># Peak indices: last n_idx valid values</span>
        <span class="n">last_valid_idx</span> <span class="o">=</span> <span class="n">first_valid_idx</span> <span class="o">+</span> <span class="n">n_valid</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">peak_start_idx</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">last_valid_idx</span> <span class="o">-</span> <span class="n">n_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">first_valid_idx</span><span class="p">)</span>
        
        <span class="n">peak_indices</span> <span class="o">=</span> <span class="n">peak_start_idx</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">idx_range</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">peak_indices</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">peak_indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sorted_sub</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># Gather peak values</span>
        <span class="n">peak_values</span> <span class="o">=</span> <span class="n">sorted_sub</span><span class="p">[</span><span class="n">peak_indices</span><span class="p">,</span> <span class="n">frame_indices</span><span class="p">]</span>
        <span class="n">peak_mask</span> <span class="o">=</span> <span class="n">idx_range</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">n_idx</span><span class="p">,</span> <span class="n">n_valid</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">peak_values</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">peak_mask</span><span class="p">,</span> <span class="n">peak_values</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">peak</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">peak_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">jnp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">peak_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">carry</span><span class="p">,</span> <span class="p">(</span><span class="n">valley</span><span class="p">,</span> <span class="n">peak</span><span class="p">)</span>
    
    <span class="c1"># Process all bands</span>
    <span class="n">carry</span> <span class="o">=</span> <span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">octa</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">n_bands</span><span class="p">,</span> <span class="n">quantile</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="n">valleys</span><span class="p">,</span> <span class="n">peaks</span><span class="p">)</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">lax</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span>
        <span class="n">process_band</span><span class="p">,</span> <span class="n">carry</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_bands</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>
    
    <span class="c1"># Compute contrast</span>
    <span class="k">if</span> <span class="n">linear</span><span class="p">:</span>
        <span class="n">contrast</span> <span class="o">=</span> <span class="n">peaks</span> <span class="o">-</span> <span class="n">valleys</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">contrast</span> <span class="o">=</span> <span class="n">power_to_db</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="o">-</span> <span class="n">power_to_db</span><span class="p">(</span><span class="n">valleys</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">contrast</span></div>



<div class="viewcode-block" id="melspectrogram">
<a class="viewcode-back" href="../../../generated/librosax.feature.melspectrogram.html#librosax.feature.melspectrogram">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">melspectrogram</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">22050</span><span class="p">,</span>
    <span class="n">S</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
    <span class="n">win_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">power</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
    <span class="n">n_mels</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span>
    <span class="n">fmin</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">fmax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">htk</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;slaney&quot;</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute a mel-scaled spectrogram.</span>

<span class="sd">    If a time-series input y is provided, its magnitude spectrogram S is</span>
<span class="sd">    first computed, and then mapped onto the mel scale by mel_f.dot(S**power).</span>

<span class="sd">    By default, power=2 operates on a power spectrum.</span>

<span class="sd">    Note:</span>
<span class="sd">        For JAX JIT compilation, all arguments except ``y`` and ``S`` should be marked as static:</span>
<span class="sd">        ``sr``, ``n_fft``, ``hop_length``, ``win_length``, ``window``, ``center``, ``pad_mode``,</span>
<span class="sd">        ``power``, ``n_mels``, ``fmin``, ``fmax``, ``htk``, ``norm``, ``dtype``</span>

<span class="sd">    Args:</span>
<span class="sd">        y: Audio time series. The last axis must be time.</span>

<span class="sd">            - ``(T,)`` - single waveform</span>
<span class="sd">            - ``(B, T)`` - batch of waveforms</span>

<span class="sd">        sr: Audio sampling rate</span>
<span class="sd">        S: (optional) Pre-computed spectrogram magnitude with shape ``(..., F, N)``</span>
<span class="sd">        n_fft: FFT window size</span>
<span class="sd">        hop_length: Hop length for STFT</span>
<span class="sd">        win_length: Window length</span>
<span class="sd">        window: Window function</span>
<span class="sd">        center: If True, pad the signal</span>
<span class="sd">        pad_mode: Padding mode</span>
<span class="sd">        power: Exponent for the magnitude melspectrogram.</span>
<span class="sd">            e.g., 1 for energy, 2 for power, etc.</span>
<span class="sd">            If 0, return the STFT magnitude directly.</span>
<span class="sd">        n_mels: Number of mel bands to generate</span>
<span class="sd">        fmin: Lowest frequency (in Hz)</span>
<span class="sd">        fmax: Highest frequency (in Hz). If None, use fmax = sr / 2.0</span>
<span class="sd">        htk: Use HTK formula instead of Slaney</span>
<span class="sd">        norm: {None, &quot;slaney&quot;, float &gt; 0}</span>
<span class="sd">            If &quot;slaney&quot;, divide the triangular mel weights by the width of the</span>
<span class="sd">            mel band (area normalization).</span>
<span class="sd">            If numeric, use norm as a mel exponent normalization.</span>
<span class="sd">            See librosax.filters.mel for details.</span>
<span class="sd">        dtype: Data type of the output array</span>

<span class="sd">    Returns:</span>
<span class="sd">        Mel spectrogram with shape ``(..., n_mels, N)``.</span>

<span class="sd">        - ``(T,)`` → ``(n_mels, N)``</span>
<span class="sd">        - ``(B, T)`` → ``(B, n_mels, N)``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fmax</span> <span class="o">=</span> <span class="n">sr</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="c1"># Compute the spectrogram magnitude</span>
    <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span>
            <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
            <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
            <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
            <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
            <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Apply power scaling if needed</span>
        <span class="k">if</span> <span class="n">power</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">power</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># When S is provided, it&#39;s already at the desired power scale</span>
        <span class="c1"># So just convert dtype</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># We need to infer n_fft from the spectrogram shape</span>
        <span class="n">n_fft</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Build mel filter matrix (already returns JAX array)</span>
    <span class="n">mel_basis</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">mel</span><span class="p">(</span>
        <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">n_mels</span><span class="o">=</span><span class="n">n_mels</span><span class="p">,</span>
        <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span>
        <span class="n">fmax</span><span class="o">=</span><span class="n">fmax</span><span class="p">,</span>
        <span class="n">htk</span><span class="o">=</span><span class="n">htk</span><span class="p">,</span>
        <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Apply mel filterbank</span>
    <span class="c1"># mel_basis shape: (n_mels, 1 + n_fft/2)</span>
    <span class="c1"># S shape: (..., 1 + n_fft/2, t)</span>
    <span class="c1"># Use einsum for flexible dimensions</span>
    <span class="n">melspec</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...ft,mf-&gt;...mt&quot;</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">mel_basis</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">melspec</span></div>



<div class="viewcode-block" id="mfcc">
<a class="viewcode-back" href="../../../generated/librosax.feature.mfcc.html#librosax.feature.mfcc">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mfcc</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">22050</span><span class="p">,</span>
    <span class="n">S</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_mfcc</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="n">dct_type</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;ortho&quot;</span><span class="p">,</span>
    <span class="n">lifter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
    <span class="n">win_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">power</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
    <span class="n">n_mels</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span>
    <span class="n">fmin</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">fmax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">htk</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">melspectrogram_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute Mel-frequency cepstral coefficients (MFCCs).</span>

<span class="sd">    MFCCs are computed from the log-power mel spectrogram.</span>

<span class="sd">    Note:</span>
<span class="sd">        For JAX JIT compilation, all arguments except ``y`` and ``S`` should be marked as static.</span>
<span class="sd">        This includes all the melspectrogram parameters and MFCC-specific parameters:</span>
<span class="sd">        ``sr``, ``n_mfcc``, ``dct_type``, ``norm``, ``lifter``, plus all other kwargs.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: Audio time series. The last axis must be time.</span>

<span class="sd">            - ``(T,)`` - single waveform</span>
<span class="sd">            - ``(B, T)`` - batch of waveforms</span>

<span class="sd">        sr: Audio sampling rate</span>
<span class="sd">        S: (optional) log-power mel spectrogram with shape ``(..., n_mels, N)``</span>
<span class="sd">        n_mfcc: Number of MFCCs to return (default: 20)</span>
<span class="sd">        dct_type: Discrete cosine transform (DCT) type (default: 2)</span>
<span class="sd">        norm: If &quot;ortho&quot;, use orthonormal DCT basis. Default: &quot;ortho&quot;</span>
<span class="sd">        lifter: If lifter&gt;0, apply liftering (cepstral filtering) to the MFCCs.</span>
<span class="sd">            If lifter=0, no liftering is applied.</span>
<span class="sd">        n_fft: FFT window size (used if y is provided)</span>
<span class="sd">        hop_length: Hop length for STFT (used if y is provided)</span>
<span class="sd">        win_length: Window length (used if y is provided)</span>
<span class="sd">        window: Window function (used if y is provided)</span>
<span class="sd">        center: If True, pad the signal (used if y is provided)</span>
<span class="sd">        pad_mode: Padding mode (used if y is provided)</span>
<span class="sd">        power: Exponent for the magnitude melspectrogram (used if y is provided)</span>
<span class="sd">        n_mels: Number of mel bands (used if y is provided)</span>
<span class="sd">        fmin: Lowest frequency in Hz (used if y is provided)</span>
<span class="sd">        fmax: Highest frequency in Hz (used if y is provided)</span>
<span class="sd">        htk: Use HTK formula for mel scale (used if y is provided)</span>
<span class="sd">        melspectrogram_params: Additional keyword arguments for melspectrogram</span>
<span class="sd">            (used if y is provided)</span>

<span class="sd">    Returns:</span>
<span class="sd">        MFCCs with shape ``(..., n_mfcc, N)``.</span>

<span class="sd">        - ``(T,)`` → ``(n_mfcc, N)``</span>
<span class="sd">        - ``(B, T)`` → ``(B, n_mfcc, N)``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Compute mel spectrogram if not provided</span>
        <span class="n">mel_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
            <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
            <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
            <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
            <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
            <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
            <span class="n">power</span><span class="o">=</span><span class="n">power</span><span class="p">,</span>
            <span class="n">n_mels</span><span class="o">=</span><span class="n">n_mels</span><span class="p">,</span>
            <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span>
            <span class="n">fmax</span><span class="o">=</span><span class="n">fmax</span><span class="p">,</span>
            <span class="n">htk</span><span class="o">=</span><span class="n">htk</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="s2">&quot;slaney&quot;</span><span class="p">,</span>  <span class="c1"># Default mel normalization for librosa</span>
        <span class="p">)</span>

        <span class="c1"># Override with any custom parameters</span>
        <span class="k">if</span> <span class="n">melspectrogram_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mel_params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">melspectrogram_params</span><span class="p">)</span>

        <span class="n">S</span> <span class="o">=</span> <span class="n">melspectrogram</span><span class="p">(</span><span class="o">**</span><span class="n">mel_params</span><span class="p">)</span>

        <span class="c1"># Convert to log scale</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">power_to_db</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="c1"># Note: S has shape (..., n_mels, t)</span>
    <span class="c1"># Need to transpose for DCT which expects (..., t, n_mels)</span>
    <span class="n">S_transposed</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Apply DCT using the shared _dct_flexible function</span>
    <span class="n">mfccs</span> <span class="o">=</span> <span class="n">_dct_flexible</span><span class="p">(</span><span class="n">S_transposed</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">dct_type</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Keep only the first n_mfcc coefficients</span>
    <span class="n">mfccs</span> <span class="o">=</span> <span class="n">mfccs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">n_mfcc</span><span class="p">]</span>

    <span class="c1"># Transpose back to (..., n_mfcc, t)</span>
    <span class="n">mfccs</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">mfccs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Apply liftering if requested</span>
    <span class="k">if</span> <span class="n">lifter</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Create liftering coefficients</span>
        <span class="c1"># Shape: (n_mfcc,) which will broadcast correctly with (..., n_mfcc, t)</span>
        <span class="n">LI</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">n_mfcc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mfccs</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">/</span> <span class="n">lifter</span><span class="p">)</span>
        <span class="n">LI</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">lifter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">LI</span>

        <span class="c1"># Reshape for broadcasting: (n_mfcc,) -&gt; (n_mfcc, 1) for shape (..., n_mfcc, t)</span>
        <span class="c1"># LI needs to align with the n_mfcc dimension</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">mfccs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">n_mfcc</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">LI</span> <span class="o">=</span> <span class="n">LI</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">mfccs</span> <span class="o">=</span> <span class="n">mfccs</span> <span class="o">*</span> <span class="n">LI</span>

    <span class="k">return</span> <span class="n">mfccs</span></div>



<div class="viewcode-block" id="hz_to_octs">
<a class="viewcode-back" href="../../../generated/librosax.feature.hz_to_octs.html#librosax.feature.hz_to_octs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">hz_to_octs</span><span class="p">(</span><span class="n">frequencies</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">tuning</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">bins_per_octave</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">12</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert frequencies (Hz) to octave numbers.</span>

<span class="sd">    Args:</span>
<span class="sd">        frequencies: Array of frequencies in Hz</span>
<span class="sd">        tuning: Tuning deviation from A440 in fractional bins</span>
<span class="sd">        bins_per_octave: Number of bins per octave (default: 12)</span>

<span class="sd">    Returns:</span>
<span class="sd">        jnp.ndarray: Octave numbers (C1 = 0, C2 = 1, ..., A4 = 4.75)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A440</span> <span class="o">=</span> <span class="mf">440.0</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="n">tuning</span> <span class="o">/</span> <span class="n">bins_per_octave</span><span class="p">)</span>
    <span class="c1"># C1 is 4 octaves below A4</span>
    <span class="n">octs</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">/</span> <span class="p">(</span><span class="n">A440</span> <span class="o">/</span> <span class="mi">16</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">octs</span></div>



<div class="viewcode-block" id="chroma_filter">
<a class="viewcode-back" href="../../../generated/librosax.feature.chroma_filter.html#librosax.feature.chroma_filter">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">chroma_filter</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sr</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n_chroma</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
    <span class="n">tuning</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">ctroct</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">,</span>
    <span class="n">octwidth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">base_c</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a chroma filter bank.</span>

<span class="sd">    Creates a linear transformation matrix to project FFT bins onto chroma bins.</span>

<span class="sd">    Args:</span>
<span class="sd">        sr: Sampling rate</span>
<span class="sd">        n_fft: Number of FFT bins</span>
<span class="sd">        n_chroma: Number of chroma bins to produce (default: 12)</span>
<span class="sd">        tuning: Tuning deviation from A440 in fractional bins (default: 0.0)</span>
<span class="sd">        ctroct: Center of Gaussian weighting in octaves (default: 5.0)</span>
<span class="sd">        octwidth: Gaussian half-width for weighting. None for flat weighting (default: 2)</span>
<span class="sd">        norm: Normalization factor for filter weights. None for no normalization (default: 2)</span>
<span class="sd">        base_c: If True, start filter bank at C. If False, start at A (default: True)</span>
<span class="sd">        dtype: Data type for filter bank</span>

<span class="sd">    Returns:</span>
<span class="sd">        jnp.ndarray: Chroma filter bank [shape=(n_chroma, 1 + n_fft/2)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wts</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_chroma</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Get the FFT bins, not counting the DC component</span>
    <span class="n">frequencies</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="n">frqbins</span> <span class="o">=</span> <span class="n">n_chroma</span> <span class="o">*</span> <span class="n">hz_to_octs</span><span class="p">(</span>
        <span class="n">frequencies</span><span class="p">,</span> <span class="n">tuning</span><span class="o">=</span><span class="n">tuning</span><span class="p">,</span> <span class="n">bins_per_octave</span><span class="o">=</span><span class="n">n_chroma</span>
    <span class="p">)</span>

    <span class="c1"># make up a value for the 0 Hz bin = 1.5 octaves below bin 1</span>
    <span class="c1"># (so chroma is 50% rotated from bin 1, and bin width is broad)</span>
    <span class="n">frqbins</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">frqbins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">n_chroma</span><span class="p">]),</span> <span class="n">frqbins</span><span class="p">])</span>

    <span class="n">binwidthbins</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">jnp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">frqbins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">frqbins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])])</span>

    <span class="c1"># Create the chroma matrix</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_chroma</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)[</span><span class="n">jnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">frqbins</span><span class="p">[:,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="n">n_chroma2</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n_chroma</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Project into range -n_chroma/2 .. n_chroma/2</span>
    <span class="c1"># add on fixed offset of 10*n_chroma to ensure all values passed to</span>
    <span class="c1"># remainder are positive</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">D</span> <span class="o">+</span> <span class="n">n_chroma2</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">n_chroma</span><span class="p">,</span> <span class="n">n_chroma</span><span class="p">)</span> <span class="o">-</span> <span class="n">n_chroma2</span>

    <span class="c1"># Gaussian bumps - 2*D to make them narrower</span>
    <span class="n">wts</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">D</span> <span class="o">/</span> <span class="n">binwidthbins</span><span class="p">[:,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Transpose to match expected shape</span>
    <span class="n">wts</span> <span class="o">=</span> <span class="n">wts</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># normalize each column</span>
    <span class="n">wts</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">wts</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Maybe apply scaling for fft bins</span>
    <span class="k">if</span> <span class="n">octwidth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wts</span> <span class="o">=</span> <span class="n">wts</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(((</span><span class="n">frqbins</span> <span class="o">/</span> <span class="n">n_chroma</span> <span class="o">-</span> <span class="n">ctroct</span><span class="p">)</span> <span class="o">/</span> <span class="n">octwidth</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">base_c</span><span class="p">:</span>
        <span class="n">wts</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">wts</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_chroma</span> <span class="o">//</span> <span class="mi">12</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># remove aliasing columns, only take up to n_fft/2 + 1</span>
    <span class="k">return</span> <span class="n">wts</span><span class="p">[:,</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">n_fft</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span></div>



<div class="viewcode-block" id="cqt_frequencies">
<a class="viewcode-back" href="../../../generated/librosax.feature.cqt_frequencies.html#librosax.feature.cqt_frequencies">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cqt_frequencies</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">n_bins</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">84</span><span class="p">,</span>
    <span class="n">bins_per_octave</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
    <span class="n">fmin</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">32.70</span><span class="p">,</span>
    <span class="n">tuning</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the center frequencies of Constant-Q bins.</span>

<span class="sd">    Args:</span>
<span class="sd">        n_bins: Number of frequency bins</span>
<span class="sd">        bins_per_octave: Number of bins per octave</span>
<span class="sd">        fmin: Minimum frequency (Hz)</span>
<span class="sd">        tuning: Tuning deviation from A440 in fractions of a bin</span>

<span class="sd">    Returns:</span>
<span class="sd">        jnp.ndarray: Center frequencies for each CQT bin</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">correction</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="n">tuning</span> <span class="o">/</span> <span class="n">bins_per_octave</span><span class="p">)</span>

    <span class="c1"># Generate geometric sequence of frequencies</span>
    <span class="n">frequencies</span> <span class="o">=</span> <span class="n">fmin</span> <span class="o">*</span> <span class="n">correction</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_bins</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins_per_octave</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">frequencies</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">cqt_frequencies_np</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">n_bins</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">84</span><span class="p">,</span>
    <span class="n">bins_per_octave</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
    <span class="n">fmin</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">32.70</span><span class="p">,</span>
    <span class="n">tuning</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the center frequencies of Constant-Q bins using numpy.</span>
<span class="sd">    </span>
<span class="sd">    This is used internally for filter bank creation to avoid JIT issues.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">correction</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="n">tuning</span> <span class="o">/</span> <span class="n">bins_per_octave</span><span class="p">)</span>
    <span class="n">frequencies</span> <span class="o">=</span> <span class="n">fmin</span> <span class="o">*</span> <span class="n">correction</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_bins</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins_per_octave</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">frequencies</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_create_cqt_kernels</span><span class="p">(</span>
    <span class="n">Q</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">sr</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">fmin</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">n_bins</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">bins_per_octave</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">fmax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">topbin_check</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">n_fft_fixed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create CQT kernels following nnAudio&#39;s implementation.</span>
<span class="sd">    </span>
<span class="sd">    This function creates the CQT kernels in time domain, similar to nnAudio&#39;s</span>
<span class="sd">    create_cqt_kernels function. Uses numpy with float64 for better precision.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        kernels: Complex CQT kernels in time domain</span>
<span class="sd">        fftLen: FFT length used</span>
<span class="sd">        lengths: Length of each filter</span>
<span class="sd">        freqs: Center frequencies for each bin</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Use numpy for better precision</span>
    <span class="c1"># Calculate frequencies for each bin</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">n_bins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">n_bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">bins_per_octave</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">fmax</span> <span class="o">/</span> <span class="n">fmin</span><span class="p">)))</span>
        <span class="n">freqs_np</span> <span class="o">=</span> <span class="n">fmin</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_bins</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">bins_per_octave</span><span class="p">))</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">fmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">n_bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">freqs_np</span> <span class="o">=</span> <span class="n">fmin</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_bins</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">bins_per_octave</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If both are given, use fmax to calculate n_bins</span>
        <span class="k">if</span> <span class="n">fmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">bins_per_octave</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">fmax</span> <span class="o">/</span> <span class="n">fmin</span><span class="p">)))</span>
        <span class="n">freqs_np</span> <span class="o">=</span> <span class="n">fmin</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_bins</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">bins_per_octave</span><span class="p">))</span>
    
    <span class="c1"># Calculate filter lengths using nnAudio&#39;s formula</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">bins_per_octave</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span>
    <span class="n">lengths_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Q</span> <span class="o">*</span> <span class="n">sr</span> <span class="o">/</span> <span class="p">(</span><span class="n">freqs_np</span> <span class="o">+</span> <span class="n">gamma</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    
    <span class="c1"># Calculate FFT length</span>
    <span class="n">max_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lengths_np</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">n_fft_fixed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Calculate based on max length, but use a power of 2</span>
        <span class="n">fftLen</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">max_len</span><span class="p">))))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If fixed FFT length is provided, ensure it&#39;s at least as large as max kernel</span>
        <span class="n">fftLen</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">n_fft_fixed</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">max_len</span><span class="p">)))))</span>
    
    <span class="c1"># Create kernels in numpy with float64</span>
    <span class="n">kernels_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_bins</span><span class="p">,</span> <span class="n">fftLen</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    
    <span class="c1"># Create each kernel using numpy</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bins</span><span class="p">):</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freqs_np</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lengths_np</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        
        <span class="c1"># Center the kernel following nnAudio&#39;s logic</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">fftLen</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">l</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">fftLen</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">l</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">))</span>
        
        <span class="c1"># Apply window using scipy to match nnAudio exactly</span>
        <span class="k">if</span> <span class="n">window</span> <span class="o">==</span> <span class="s2">&quot;hann&quot;</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.signal</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_window</span>
            <span class="n">window_dispatch</span> <span class="o">=</span> <span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">fftbins</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">window_dispatch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="c1"># Create complex sinusoid following nnAudio exactly</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">window_dispatch</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="o">-</span><span class="n">l</span> <span class="o">//</span> <span class="mi">2</span> <span class="p">:</span> <span class="n">l</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">/</span> <span class="n">sr</span><span class="p">)</span> <span class="o">/</span> <span class="n">l</span>
        
        <span class="c1"># Normalize if requested - match nnAudio&#39;s use of np.linalg.norm</span>
        <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">norm</span><span class="p">)</span>
        <span class="c1"># Note: if norm is None or 0, no normalization is applied</span>
        
        <span class="c1"># Place kernel in the array</span>
        <span class="n">kernels_np</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig</span>
    
    <span class="c1"># Convert to JAX arrays at the end</span>
    <span class="n">kernels</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernels_np</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
    <span class="n">lengths</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lengths_np</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">freqs_np</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">kernels</span><span class="p">,</span> <span class="n">fftLen</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="n">freqs</span>


<div class="viewcode-block" id="cqt">
<a class="viewcode-back" href="../../../generated/librosax.feature.cqt.html#librosax.feature.cqt">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cqt</span><span class="p">(</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">22050</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
    <span class="n">fmin</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_bins</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">84</span><span class="p">,</span>
    <span class="n">bins_per_octave</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
    <span class="n">tuning</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">filter_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">sparsity</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">scale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">res_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">use_1992_version</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">output_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;complex&quot;</span><span class="p">,</span>
    <span class="n">normalization_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;librosa&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the constant-Q transform following nnAudio&#39;s CQT1992v2 implementation.</span>

<span class="sd">    This implementation follows nnAudio&#39;s CQT1992v2 algorithm which computes the CQT</span>
<span class="sd">    efficiently by convolving the time-domain signal with CQT kernels.</span>

<span class="sd">    Note:</span>
<span class="sd">        For JAX JIT compilation, all arguments except ``y`` should be marked as static:</span>
<span class="sd">        ``sr``, ``hop_length``, ``fmin``, ``n_bins``, ``bins_per_octave``, ``tuning``,</span>
<span class="sd">        ``filter_scale``, ``norm``, ``sparsity``, ``window``, ``scale``, ``pad_mode``,</span>
<span class="sd">        ``res_type``, ``dtype``, ``n_fft``, ``use_1992_version``, ``output_format``,</span>
<span class="sd">        ``normalization_type``</span>

<span class="sd">    Args:</span>
<span class="sd">        y: Audio time series. The last axis must be time.</span>

<span class="sd">            - ``(T,)`` - single waveform</span>
<span class="sd">            - ``(B, T)`` - batch of waveforms</span>

<span class="sd">        sr: Sampling rate</span>
<span class="sd">        hop_length: Number of samples between successive CQT columns</span>
<span class="sd">        fmin: Minimum frequency (default: C1 = 32.70 Hz)</span>
<span class="sd">        n_bins: Number of frequency bins</span>
<span class="sd">        bins_per_octave: Number of bins per octave</span>
<span class="sd">        tuning: Tuning offset in fractions of a bin</span>
<span class="sd">        filter_scale: Filter scale factor (Q = filter_scale / (2^(1/bins_per_octave) - 1))</span>
<span class="sd">        norm: Normalization type for basis functions (1, 2, or None)</span>
<span class="sd">        sparsity: Sparsification factor (not implemented)</span>
<span class="sd">        window: Window function</span>
<span class="sd">        scale: If True, scale by sqrt(filter_lengths) following librosa normalization</span>
<span class="sd">        pad_mode: Padding mode</span>
<span class="sd">        res_type: Resampling type (not used in 1992 version)</span>
<span class="sd">        dtype: Complex data type</span>
<span class="sd">        n_fft: FFT size (if None, calculated automatically)</span>
<span class="sd">        use_1992_version: If True, use CQT1992v2 algorithm (recommended)</span>
<span class="sd">        output_format: Output format (&#39;complex&#39;, &#39;magnitude&#39;, &#39;phase&#39;)</span>
<span class="sd">        normalization_type: Normalization type (&#39;librosa&#39;, &#39;convolutional&#39;, &#39;wrap&#39;)</span>

<span class="sd">    Returns:</span>
<span class="sd">        CQT matrix with shape ``(..., n_bins, N)``. Format depends on output_format.</span>

<span class="sd">        - ``(T,)`` → ``(n_bins, N)``</span>
<span class="sd">        - ``(B, T)`` → ``(B, n_bins, N)``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;y cannot be None - audio input is required for CQT&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fmin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fmin</span> <span class="o">=</span> <span class="n">note_to_hz</span><span class="p">(</span><span class="s2">&quot;C1&quot;</span><span class="p">)</span>

    <span class="c1"># Apply tuning correction</span>
    <span class="n">fmin</span> <span class="o">=</span> <span class="n">fmin</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="n">tuning</span> <span class="o">/</span> <span class="n">bins_per_octave</span><span class="p">)</span>

    <span class="c1"># Calculate Q factor</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">filter_scale</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">bins_per_octave</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="c1"># Create CQT kernels</span>
    <span class="n">cqt_kernels</span><span class="p">,</span> <span class="n">kernel_width</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">_create_cqt_kernels</span><span class="p">(</span>
        <span class="n">Q</span><span class="o">=</span><span class="n">Q</span><span class="p">,</span>
        <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
        <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span>
        <span class="n">n_bins</span><span class="o">=</span><span class="n">n_bins</span><span class="p">,</span>
        <span class="n">bins_per_octave</span><span class="o">=</span><span class="n">bins_per_octave</span><span class="p">,</span>
        <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">n_fft_fixed</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Track if we need to squeeze batch dimension later</span>
    <span class="n">squeeze_batch</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">squeeze_batch</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># y is now 2D (batch, time)</span>

    <span class="c1"># Pad the signal if center is True</span>
    <span class="k">if</span> <span class="n">pad_mode</span> <span class="o">==</span> <span class="s2">&quot;constant&quot;</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">kernel_width</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">kernel_width</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">pad_mode</span> <span class="o">==</span> <span class="s2">&quot;reflect&quot;</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">kernel_width</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">kernel_width</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">)</span>

    <span class="c1"># Take FFT of kernels once</span>
    <span class="n">cqt_kernels_fft</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">cqt_kernels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Extract only the positive frequencies</span>
    <span class="n">cqt_kernels_fft</span> <span class="o">=</span> <span class="n">cqt_kernels_fft</span><span class="p">[:,</span> <span class="p">:</span><span class="n">kernel_width</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    
    <span class="c1"># Compute STFT for all batch elements at once</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">jssignal</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span>
        <span class="n">y</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="s2">&quot;boxcar&quot;</span><span class="p">,</span>  <span class="c1"># rectangular window since CQT kernels already have windows</span>
        <span class="n">nperseg</span><span class="o">=</span><span class="n">kernel_width</span><span class="p">,</span>
        <span class="n">noverlap</span><span class="o">=</span><span class="n">kernel_width</span> <span class="o">-</span> <span class="n">hop_length</span><span class="p">,</span>
        <span class="n">nfft</span><span class="o">=</span><span class="n">kernel_width</span><span class="p">,</span>
        <span class="n">boundary</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># No padding, we already padded</span>
        <span class="n">padded</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="c1"># Multiply in frequency domain</span>
    <span class="c1"># D shape: (batch, freq_bins, time_frames) for batched input</span>
    <span class="c1"># cqt_kernels_fft shape: (n_bins, freq_bins)</span>
    <span class="c1"># Result shape: (batch, n_bins, time_frames)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;bf,...ft-&gt;...bt&#39;</span><span class="p">,</span> <span class="n">cqt_kernels_fft</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">D</span><span class="p">)</span>

    <span class="c1"># Apply normalization based on type</span>
    <span class="k">if</span> <span class="n">normalization_type</span> <span class="o">==</span> <span class="s2">&quot;librosa&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">scale</span><span class="p">:</span>
            <span class="c1"># Apply sqrt(lengths) normalization</span>
            <span class="c1"># When using FFT-based convolution vs nnAudio&#39;s direct convolution,</span>
            <span class="c1"># we need an additional scaling factor to match the output magnitude</span>
            <span class="c1"># This is empirically determined to match nnAudio&#39;s output</span>
            <span class="c1"># The factor depends on the kernel width and hop length</span>
            <span class="n">fft_correction</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">kernel_width</span><span class="p">)</span> <span class="o">*</span> <span class="mf">32.0</span>
            <span class="n">scale_factors</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lengths</span><span class="p">)[:,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">fft_correction</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">C</span> <span class="o">*</span> <span class="n">scale_factors</span>
    <span class="k">elif</span> <span class="n">normalization_type</span> <span class="o">==</span> <span class="s2">&quot;convolutional&quot;</span><span class="p">:</span>
        <span class="c1"># No additional normalization</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">normalization_type</span> <span class="o">==</span> <span class="s2">&quot;wrap&quot;</span><span class="p">:</span>
        <span class="c1"># Apply wrap normalization</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">C</span> <span class="o">*</span> <span class="mf">2.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown normalization type: </span><span class="si">{</span><span class="n">normalization_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Format output based on output_format</span>
    <span class="k">if</span> <span class="n">output_format</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;magnitude&quot;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">output_format</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;complex&quot;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">C</span>
    <span class="k">elif</span> <span class="n">output_format</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;phase&quot;</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">jnp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phase</span><span class="p">),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phase</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown output format: </span><span class="si">{</span><span class="n">output_format</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Remove batch dimension if we added it</span>
    <span class="k">if</span> <span class="n">squeeze_batch</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="k">return</span> <span class="n">result</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_create_lowpass_filter</span><span class="p">(</span>
    <span class="n">band_center</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
    <span class="n">kernel_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
    <span class="n">transition_bandwidth</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.03</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a lowpass filter for downsampling.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        band_center: Center frequency (normalized to Nyquist)</span>
<span class="sd">        kernel_length: Length of the filter kernel</span>
<span class="sd">        transition_bandwidth: Width of the transition band</span>
<span class="sd">        dtype: Data type for the filter</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Filter kernel coefficients</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">passband_max</span> <span class="o">=</span> <span class="n">band_center</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">transition_bandwidth</span><span class="p">)</span>
    <span class="n">stopband_min</span> <span class="o">=</span> <span class="n">band_center</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">transition_bandwidth</span><span class="p">)</span>
    
    <span class="n">key_frequencies</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">passband_max</span><span class="p">,</span> <span class="n">stopband_min</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
    <span class="n">gain_at_key_frequencies</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
    
    <span class="c1"># Use scipy for filter design</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">scipy.signal</span>
    <span class="n">filter_kernel</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">firwin2</span><span class="p">(</span><span class="n">kernel_length</span><span class="p">,</span> <span class="n">key_frequencies</span><span class="p">,</span> <span class="n">gain_at_key_frequencies</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filter_kernel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_next_power_of_2</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the next power of 2.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_early_downsample_count</span><span class="p">(</span>
    <span class="n">nyquist_hz</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">filter_cutoff_hz</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n_octaves</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the number of early downsampling operations.&quot;&quot;&quot;</span>
    <span class="n">downsample_count1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="mf">0.85</span> <span class="o">*</span> <span class="n">nyquist_hz</span> <span class="o">/</span> <span class="n">filter_cutoff_hz</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">num_twos</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">hop_length</span><span class="p">)))</span>
    <span class="n">downsample_count2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_twos</span> <span class="o">-</span> <span class="n">n_octaves</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">downsample_count1</span><span class="p">,</span> <span class="n">downsample_count2</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_early_downsample_params</span><span class="p">(</span>
    <span class="n">sr</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">fmax_t</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">Q</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">n_octaves</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute downsampling parameters for early downsampling.&quot;&quot;&quot;</span>
    <span class="n">window_bandwidth</span> <span class="o">=</span> <span class="mf">1.5</span>  <span class="c1"># for hann window</span>
    <span class="n">filter_cutoff</span> <span class="o">=</span> <span class="n">fmax_t</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">window_bandwidth</span> <span class="o">/</span> <span class="n">Q</span><span class="p">)</span>
    
    <span class="n">downsample_count</span> <span class="o">=</span> <span class="n">_early_downsample_count</span><span class="p">(</span><span class="n">sr</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">filter_cutoff</span><span class="p">,</span> <span class="n">hop_length</span><span class="p">,</span> <span class="n">n_octaves</span><span class="p">)</span>
    <span class="n">downsample_factor</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">downsample_count</span>
    
    <span class="n">hop_length</span> <span class="o">//=</span> <span class="n">downsample_factor</span>
    <span class="n">new_sr</span> <span class="o">=</span> <span class="n">sr</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">downsample_factor</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">downsample_factor</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">early_downsample_filter</span> <span class="o">=</span> <span class="n">_create_lowpass_filter</span><span class="p">(</span>
            <span class="n">band_center</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="n">downsample_factor</span><span class="p">,</span>
            <span class="n">kernel_length</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span>
            <span class="n">transition_bandwidth</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">early_downsample_filter</span> <span class="o">=</span> <span class="kc">None</span>
        
    <span class="k">return</span> <span class="n">new_sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="p">,</span> <span class="n">downsample_factor</span><span class="p">,</span> <span class="n">early_downsample_filter</span>


<span class="nd">@partial</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">))</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_downsample_by_n</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">filter_kernel</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Downsample signal by factor n using the given filter.</span>
<span class="sd">    </span>
<span class="sd">    This matches nnAudio&#39;s approach using strided convolution with padding.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculate padding to match nnAudio</span>
    <span class="n">padding</span> <span class="o">=</span> <span class="p">(</span><span class="n">filter_kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    
    <span class="c1"># Apply padding</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">x_padded</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Handle other axes if needed</span>
        <span class="n">pad_width</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">pad_width</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="n">padding</span><span class="p">)</span>
        <span class="n">x_padded</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
    
    <span class="c1"># Apply filter and downsample in one step using strided convolution</span>
    <span class="c1"># This ensures consistent output sizes</span>
    <span class="n">filtered</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">x_padded</span><span class="p">,</span> <span class="n">filter_kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span>
    
    <span class="c1"># Downsample</span>
    <span class="k">return</span> <span class="n">filtered</span><span class="p">[::</span><span class="n">n</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_cqt_complex</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">cqt_kernels_real</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">cqt_kernels_imag</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">pad_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute CQT using time-domain convolution.</span>
<span class="sd">    </span>
<span class="sd">    This implementation matches nnAudio&#39;s approach using strided convolution.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        x: Input signal [shape=(batch, time)]</span>
<span class="sd">        cqt_kernels_real: Real part of CQT kernels [shape=(n_bins, 1, kernel_length)]</span>
<span class="sd">        cqt_kernels_imag: Imaginary part of CQT kernels [shape=(n_bins, 1, kernel_length)]</span>
<span class="sd">        hop_length: Hop size (stride)</span>
<span class="sd">        pad_length: Padding length</span>
<span class="sd">        pad_mode: Padding mode</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Complex CQT [shape=(batch, n_bins, time, 2)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Pad the signal - matches nnAudio&#39;s center padding</span>
    <span class="k">if</span> <span class="n">pad_mode</span> <span class="o">==</span> <span class="s2">&quot;constant&quot;</span><span class="p">:</span>
        <span class="n">x_padded</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">pad_length</span><span class="p">,</span> <span class="n">pad_length</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">pad_mode</span> <span class="o">==</span> <span class="s2">&quot;reflect&quot;</span><span class="p">:</span>
        <span class="n">x_padded</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">pad_length</span><span class="p">,</span> <span class="n">pad_length</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_padded</span> <span class="o">=</span> <span class="n">x</span>
    
    <span class="c1"># Use JAX&#39;s conv_general_dilated_local for 1D strided convolution</span>
    <span class="c1"># This ensures consistent output sizes like PyTorch&#39;s conv1d</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">jax</span><span class="w"> </span><span class="kn">import</span> <span class="n">lax</span>
    
    <span class="c1"># Reshape inputs for conv_general_dilated</span>
    <span class="c1"># x needs shape: (batch, in_channels=1, time)</span>
    <span class="c1"># kernels need shape: (out_channels, in_channels=1, kernel_length)</span>
    <span class="n">x_reshaped</span> <span class="o">=</span> <span class="n">x_padded</span><span class="p">[:,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># Add channel dimension</span>
    
    <span class="c1"># Ensure kernels have the right shape</span>
    <span class="k">if</span> <span class="n">cqt_kernels_real</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Shape is (n_bins, kernel_length), need to add channel dimension</span>
        <span class="n">kernels_real</span> <span class="o">=</span> <span class="n">cqt_kernels_real</span><span class="p">[:,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">kernels_imag</span> <span class="o">=</span> <span class="n">cqt_kernels_imag</span><span class="p">[:,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Already has channel dimension</span>
        <span class="n">kernels_real</span> <span class="o">=</span> <span class="n">cqt_kernels_real</span>
        <span class="n">kernels_imag</span> <span class="o">=</span> <span class="n">cqt_kernels_imag</span>
    
    <span class="c1"># Perform strided convolution</span>
    <span class="c1"># dimension_numbers: (batch, channel, spatial)</span>
    <span class="n">cqt_real</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">conv_general_dilated</span><span class="p">(</span>
        <span class="n">x_reshaped</span><span class="p">,</span>
        <span class="n">kernels_real</span><span class="p">,</span>
        <span class="n">window_strides</span><span class="o">=</span><span class="p">(</span><span class="n">hop_length</span><span class="p">,),</span>
        <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;VALID&#39;</span><span class="p">,</span>
        <span class="n">dimension_numbers</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;NCH&#39;</span><span class="p">,</span> <span class="s1">&#39;OIH&#39;</span><span class="p">,</span> <span class="s1">&#39;NCH&#39;</span><span class="p">)</span>
    <span class="p">)</span>
    
    <span class="n">cqt_imag</span> <span class="o">=</span> <span class="o">-</span><span class="n">lax</span><span class="o">.</span><span class="n">conv_general_dilated</span><span class="p">(</span>
        <span class="n">x_reshaped</span><span class="p">,</span>
        <span class="n">kernels_imag</span><span class="p">,</span>
        <span class="n">window_strides</span><span class="o">=</span><span class="p">(</span><span class="n">hop_length</span><span class="p">,),</span>
        <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;VALID&#39;</span><span class="p">,</span>
        <span class="n">dimension_numbers</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;NCH&#39;</span><span class="p">,</span> <span class="s1">&#39;OIH&#39;</span><span class="p">,</span> <span class="s1">&#39;NCH&#39;</span><span class="p">)</span>
    <span class="p">)</span>
    
    <span class="c1"># The output shape from conv is (batch, n_bins, time)</span>
    <span class="c1"># No need to squeeze - the conv already gives us the right shape</span>
    
    <span class="c1"># Stack real and imaginary parts</span>
    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">cqt_real</span><span class="p">,</span> <span class="n">cqt_imag</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>


<div class="viewcode-block" id="cqt2010">
<a class="viewcode-back" href="../../../generated/librosax.feature.cqt2010.html#librosax.feature.cqt2010">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cqt2010</span><span class="p">(</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">22050</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
    <span class="n">fmin</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">fmax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_bins</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">84</span><span class="p">,</span>
    <span class="n">bins_per_octave</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
    <span class="n">tuning</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">filter_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">sparsity</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>  <span class="c1"># todo: not used</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">scale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;reflect&quot;</span><span class="p">,</span>
    <span class="n">res_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># todo: not used</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span>  <span class="c1"># todo: not used</span>
    <span class="n">output_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;magnitude&quot;</span><span class="p">,</span>
    <span class="n">earlydownsample</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute constant-Q transform using the 2010 algorithm with multi-resolution.</span>
<span class="sd">    </span>
<span class="sd">    This implementation follows nnAudio&#39;s CQT2010v2 algorithm which is more</span>
<span class="sd">    memory-efficient than CQT1992. It creates a small CQT kernel for the top</span>
<span class="sd">    octave and uses downsampling to compute lower octaves.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        y: Audio time series</span>
<span class="sd">        sr: Sampling rate  </span>
<span class="sd">        hop_length: Number of samples between successive CQT columns</span>
<span class="sd">        fmin: Minimum frequency (default: C1 = 32.70 Hz)</span>
<span class="sd">        fmax: Maximum frequency (default: inferred from n_bins)</span>
<span class="sd">        n_bins: Number of frequency bins</span>
<span class="sd">        bins_per_octave: Number of bins per octave</span>
<span class="sd">        tuning: Tuning offset in fractions of a bin</span>
<span class="sd">        filter_scale: Filter scale factor</span>
<span class="sd">        norm: Normalization type for basis functions</span>
<span class="sd">        sparsity: Sparsification factor (not implemented)</span>
<span class="sd">        window: Window function</span>
<span class="sd">        scale: If True, scale the output</span>
<span class="sd">        pad_mode: Padding mode</span>
<span class="sd">        res_type: Resampling type (not used)</span>
<span class="sd">        dtype: Complex data type</span>
<span class="sd">        output_format: Output format (&#39;magnitude&#39;, &#39;complex&#39;, &#39;phase&#39;)</span>
<span class="sd">        earlydownsample: If True, use early downsampling optimization</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        CQT matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fmin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fmin</span> <span class="o">=</span> <span class="n">note_to_hz</span><span class="p">(</span><span class="s2">&quot;C1&quot;</span><span class="p">)</span>
        
    <span class="c1"># Apply tuning</span>
    <span class="n">fmin</span> <span class="o">=</span> <span class="n">fmin</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="n">tuning</span> <span class="o">/</span> <span class="n">bins_per_octave</span><span class="p">)</span>
    
    <span class="c1"># Calculate Q factor</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">filter_scale</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">bins_per_octave</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
    
    <span class="c1"># Calculate number of octaves</span>
    <span class="n">n_octaves</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n_bins</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins_per_octave</span><span class="p">))</span>
    <span class="n">n_filters</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">bins_per_octave</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">)</span>
    
    <span class="c1"># Get the top octave parameters</span>
    <span class="n">fmin_t</span> <span class="o">=</span> <span class="n">fmin</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">n_octaves</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Calculate kernel parameters</span>
    <span class="k">if</span> <span class="n">fmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># If fmax is specified, adjust n_bins</span>
        <span class="n">n_bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">bins_per_octave</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">fmax</span> <span class="o">/</span> <span class="n">fmin</span><span class="p">)))</span>
        <span class="n">n_octaves</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n_bins</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins_per_octave</span><span class="p">))</span>
        <span class="n">fmin_t</span> <span class="o">=</span> <span class="n">fmin</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">n_octaves</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Check remainder to calculate top bin frequency</span>
    <span class="n">remainder</span> <span class="o">=</span> <span class="n">n_bins</span> <span class="o">%</span> <span class="n">bins_per_octave</span>
    <span class="k">if</span> <span class="n">remainder</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">fmax_t</span> <span class="o">=</span> <span class="n">fmin_t</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">((</span><span class="n">bins_per_octave</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins_per_octave</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fmax_t</span> <span class="o">=</span> <span class="n">fmin_t</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">((</span><span class="n">remainder</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins_per_octave</span><span class="p">)</span>
        
    <span class="c1"># Adjust fmin_t</span>
    <span class="n">fmin_t</span> <span class="o">=</span> <span class="n">fmax_t</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">bins_per_octave</span><span class="p">)</span>
    
    <span class="c1"># Check Nyquist</span>
    <span class="k">if</span> <span class="n">fmax_t</span> <span class="o">&gt;</span> <span class="n">sr</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The top bin </span><span class="si">{</span><span class="n">fmax_t</span><span class="si">}</span><span class="s2">Hz exceeds Nyquist frequency&quot;</span><span class="p">)</span>
        
    <span class="c1"># Get early downsample parameters if enabled</span>
    <span class="n">sample_rate</span> <span class="o">=</span> <span class="n">sr</span>
    <span class="n">hop</span> <span class="o">=</span> <span class="n">hop_length</span>
    <span class="n">downsample_factor</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">early_downsample_filter</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">earlydownsample</span><span class="p">:</span>
        <span class="n">sample_rate</span><span class="p">,</span> <span class="n">hop</span><span class="p">,</span> <span class="n">downsample_factor</span><span class="p">,</span> <span class="n">early_downsample_filter</span> <span class="o">=</span> <span class="n">_get_early_downsample_params</span><span class="p">(</span>
            <span class="n">sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="p">,</span> <span class="n">fmax_t</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">n_octaves</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>
        
    <span class="c1"># Create CQT kernels for top octave only</span>
    <span class="n">cqt_kernels</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">_create_cqt_kernels</span><span class="p">(</span>
        <span class="n">Q</span><span class="o">=</span><span class="n">Q</span><span class="p">,</span>
        <span class="n">sr</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span>
        <span class="n">fmin</span><span class="o">=</span><span class="n">fmin_t</span><span class="p">,</span>
        <span class="n">n_bins</span><span class="o">=</span><span class="n">n_filters</span><span class="p">,</span>
        <span class="n">bins_per_octave</span><span class="o">=</span><span class="n">bins_per_octave</span><span class="p">,</span>
        <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="c1"># Create lowpass filter for octave downsampling</span>
    <span class="n">lowpass_filter</span> <span class="o">=</span> <span class="n">_create_lowpass_filter</span><span class="p">(</span>
        <span class="n">band_center</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">kernel_length</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> 
        <span class="n">transition_bandwidth</span><span class="o">=</span><span class="mf">0.001</span>
    <span class="p">)</span>
    
    <span class="c1"># Track if we need to squeeze the batch dimension later</span>
    <span class="n">squeeze_batch</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">squeeze_batch</span> <span class="o">=</span> <span class="kc">True</span>
    
    <span class="c1"># Convert to float32 if needed to match kernel dtype</span>
    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        
    <span class="c1"># Apply early downsampling if enabled</span>
    <span class="k">if</span> <span class="n">earlydownsample</span> <span class="ow">and</span> <span class="n">early_downsample_filter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Process each batch element</span>
        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">_downsample_by_n</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">early_downsample_filter</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">downsample_factor</span><span class="p">))[</span><span class="n">jnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use vmap for batch processing</span>
            <span class="n">downsample_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">y_single</span><span class="p">:</span> <span class="n">_downsample_by_n</span><span class="p">(</span><span class="n">y_single</span><span class="p">,</span> <span class="n">early_downsample_filter</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">downsample_factor</span><span class="p">))</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">downsample_fn</span><span class="p">)(</span><span class="n">y</span><span class="p">)</span>
        
    <span class="c1"># Split kernels</span>
    <span class="n">cqt_kernels_real</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">cqt_kernels</span><span class="p">)[:,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">cqt_kernels_imag</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">cqt_kernels</span><span class="p">)[:,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
    
    <span class="c1"># Get CQT for top octave</span>
    <span class="n">CQT</span> <span class="o">=</span> <span class="n">_get_cqt_complex</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">cqt_kernels_real</span><span class="p">,</span> <span class="n">cqt_kernels_imag</span><span class="p">,</span> <span class="n">hop</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pad_mode</span><span class="p">)</span>
    
    <span class="c1"># Process remaining octaves</span>
    <span class="n">y_down</span> <span class="o">=</span> <span class="n">y</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_octaves</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">hop</span> <span class="o">=</span> <span class="n">hop</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="c1"># Downsample by 2</span>
        <span class="k">if</span> <span class="n">y_down</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">y_down</span> <span class="o">=</span> <span class="n">_downsample_by_n</span><span class="p">(</span><span class="n">y_down</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lowpass_filter</span><span class="p">,</span> <span class="mi">2</span><span class="p">)[</span><span class="n">jnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use vmap for batch processing</span>
            <span class="n">downsample_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">y_single</span><span class="p">:</span> <span class="n">_downsample_by_n</span><span class="p">(</span><span class="n">y_single</span><span class="p">,</span> <span class="n">lowpass_filter</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">y_down</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">downsample_fn</span><span class="p">)(</span><span class="n">y_down</span><span class="p">)</span>
        
        <span class="c1"># Get CQT for this octave</span>
        <span class="n">CQT1</span> <span class="o">=</span> <span class="n">_get_cqt_complex</span><span class="p">(</span><span class="n">y_down</span><span class="p">,</span> <span class="n">cqt_kernels_real</span><span class="p">,</span> <span class="n">cqt_kernels_imag</span><span class="p">,</span> <span class="n">hop</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pad_mode</span><span class="p">)</span>
        
        <span class="c1"># Concatenate (lower frequencies first)</span>
        <span class="n">CQT</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">CQT1</span><span class="p">,</span> <span class="n">CQT</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="c1"># Remove unwanted bins</span>
    <span class="n">CQT</span> <span class="o">=</span> <span class="n">CQT</span><span class="p">[:,</span> <span class="o">-</span><span class="n">n_bins</span><span class="p">:,</span> <span class="p">:]</span>
    
    <span class="c1"># Apply scaling</span>
    <span class="n">CQT</span> <span class="o">=</span> <span class="n">CQT</span> <span class="o">*</span> <span class="n">downsample_factor</span>
    
    <span class="c1"># Get all frequency lengths</span>
    <span class="n">all_freqs</span> <span class="o">=</span> <span class="n">fmin</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_bins</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">bins_per_octave</span><span class="p">))</span>
    <span class="n">all_lengths</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Q</span> <span class="o">*</span> <span class="n">sr</span> <span class="o">/</span> <span class="n">all_freqs</span><span class="p">)</span>
    
    <span class="c1"># Normalize</span>
    <span class="k">if</span> <span class="n">scale</span><span class="p">:</span>
        <span class="n">CQT</span> <span class="o">=</span> <span class="n">CQT</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">all_lengths</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        
    <span class="c1"># Format output based on requested format</span>
    <span class="k">if</span> <span class="n">output_format</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;magnitude&quot;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">CQT</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">output_format</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;complex&quot;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">CQT</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">CQT</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">output_format</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;phase&quot;</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">CQT</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">CQT</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">jnp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phase</span><span class="p">),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phase</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown output format: </span><span class="si">{</span><span class="n">output_format</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Remove batch dimension only if we added it</span>
    <span class="k">if</span> <span class="n">squeeze_batch</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="chroma_cqt">
<a class="viewcode-back" href="../../../generated/librosax.feature.chroma_cqt.html#librosax.feature.chroma_cqt">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">chroma_cqt</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">22050</span><span class="p">,</span>
    <span class="n">C</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
    <span class="n">fmin</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
    <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">tuning</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">n_chroma</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
    <span class="n">n_octaves</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># todo: not used yet</span>
    <span class="n">bins_per_octave</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">36</span><span class="p">,</span>
    <span class="n">cqt_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;full&quot;</span><span class="p">,</span>  <span class="c1"># todo: not used yet</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Chromagram from a constant-Q transform.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: Audio time series. The last axis must be time.</span>

<span class="sd">            - ``(T,)`` - single waveform</span>
<span class="sd">            - ``(B, T)`` - batch of waveforms</span>

<span class="sd">        sr: Sampling rate</span>
<span class="sd">        C: Pre-computed CQT spectrogram with shape ``(..., n_cqt_bins, N)``</span>
<span class="sd">        hop_length: Number of samples between successive CQT columns</span>
<span class="sd">        fmin: Minimum frequency. Default: C1 ~= 32.70 Hz</span>
<span class="sd">        norm: Normalization mode for chroma</span>
<span class="sd">        threshold: Pre-normalization energy threshold</span>
<span class="sd">        tuning: Tuning deviation from A440 in fractional bins</span>
<span class="sd">        n_chroma: Number of chroma bins to produce</span>
<span class="sd">        n_octaves: Number of octaves to analyze above fmin</span>
<span class="sd">        window: Optional weighting window</span>
<span class="sd">        bins_per_octave: Number of bins per octave in the CQT</span>
<span class="sd">        cqt_mode: CQT mode (&#39;full&#39; or &#39;hybrid&#39;)</span>
<span class="sd">        **kwargs: Additional parameters for cqt</span>

<span class="sd">    Returns:</span>
<span class="sd">        Chromagram with shape ``(..., n_chroma, N)``.</span>

<span class="sd">        - ``(T,)`` → ``(n_chroma, N)``</span>
<span class="sd">        - ``(B, T)`` → ``(B, n_chroma, N)``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">C</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;Either y or C must be provided&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fmin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fmin</span> <span class="o">=</span> <span class="n">note_to_hz</span><span class="p">(</span><span class="s2">&quot;C1&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">cqt</span><span class="p">(</span>
            <span class="n">y</span><span class="p">,</span>
            <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
            <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
            <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span>
            <span class="n">n_bins</span><span class="o">=</span><span class="n">n_octaves</span> <span class="o">*</span> <span class="n">bins_per_octave</span><span class="p">,</span>
            <span class="n">bins_per_octave</span><span class="o">=</span><span class="n">bins_per_octave</span><span class="p">,</span>
            <span class="n">tuning</span><span class="o">=</span><span class="n">tuning</span><span class="p">,</span>
            <span class="n">output_format</span><span class="o">=</span><span class="s2">&quot;magnitude&quot;</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Map CQT bins to chroma bins</span>
    <span class="c1"># This is a simplified version - proper implementation would use</span>
    <span class="c1"># cq_to_chroma matrix from librosa</span>
    <span class="n">n_cqt_bins</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># Create a proper mapping matrix from CQT bins to chroma bins</span>
    <span class="c1"># The key insight is that if bins_per_octave is a multiple of n_chroma,</span>
    <span class="c1"># then we can group consecutive CQT bins into chroma bins</span>
    <span class="n">bins_per_chroma</span> <span class="o">=</span> <span class="n">bins_per_octave</span> <span class="o">//</span> <span class="n">n_chroma</span>

    <span class="c1"># Create the mapping matrix</span>
    <span class="c1"># Vectorized version for JAX compatibility</span>
    <span class="n">bin_indices</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_cqt_bins</span><span class="p">)</span>
    <span class="n">chroma_indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_indices</span> <span class="o">//</span> <span class="n">bins_per_chroma</span><span class="p">)</span> <span class="o">%</span> <span class="n">n_chroma</span>

    <span class="n">cq_to_chr</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_chroma</span><span class="p">,</span> <span class="n">n_cqt_bins</span><span class="p">))</span>
    <span class="n">cq_to_chr</span> <span class="o">=</span> <span class="n">cq_to_chr</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">chroma_indices</span><span class="p">,</span> <span class="n">bin_indices</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

    <span class="c1"># Apply the mapping</span>
    <span class="c1"># C shape: (..., n_cqt_bins, t)</span>
    <span class="c1"># cq_to_chr shape: (n_chroma, n_cqt_bins)</span>
    <span class="c1"># Result shape: (..., n_chroma, t)</span>
    <span class="n">chroma</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...ct,bc-&gt;...bt&quot;</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">cq_to_chr</span><span class="p">)</span>

    <span class="c1"># Apply threshold</span>
    <span class="k">if</span> <span class="n">threshold</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">chroma</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">chroma</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">chroma</span><span class="p">)</span>

    <span class="c1"># Normalize</span>
    <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">chroma</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">chroma</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">chroma</span></div>



<div class="viewcode-block" id="tonnetz">
<a class="viewcode-back" href="../../../generated/librosax.feature.tonnetz.html#librosax.feature.tonnetz">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">tonnetz</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">22050</span><span class="p">,</span>
    <span class="n">chroma</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the tonal centroid features (tonnetz).</span>

<span class="sd">    This representation projects chroma features onto a 6-dimensional basis</span>
<span class="sd">    representing the perfect fifth, minor third, and major third each as</span>
<span class="sd">    two-dimensional coordinates.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: Audio time series. The last axis must be time.</span>

<span class="sd">            - ``(T,)`` - single waveform</span>
<span class="sd">            - ``(B, T)`` - batch of waveforms</span>

<span class="sd">        sr: Sampling rate of y</span>
<span class="sd">        chroma: Normalized energy for each chroma bin at each frame</span>
<span class="sd">            with shape ``(..., n_chroma, N)``. If None, a chroma_stft is computed.</span>
<span class="sd">        **kwargs: Additional keyword arguments to chroma_stft,</span>
<span class="sd">            if chroma is not pre-computed.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tonnetz features with shape ``(..., 6, N)``.</span>

<span class="sd">        - ``(T,)`` → ``(6, N)``</span>
<span class="sd">        - ``(B, T)`` → ``(B, 6, N)``</span>

<span class="sd">        Tonnetz dimensions:</span>

<span class="sd">        - 0: Fifth x-axis</span>
<span class="sd">        - 1: Fifth y-axis</span>
<span class="sd">        - 2: Minor x-axis</span>
<span class="sd">        - 3: Minor y-axis</span>
<span class="sd">        - 4: Major x-axis</span>
<span class="sd">        - 5: Major y-axis</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">chroma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;Either the audio samples or the chromagram must be &quot;</span>
            <span class="s2">&quot;passed as an argument.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">chroma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Use chroma_stft instead of chroma_cqt for now</span>
        <span class="n">chroma</span> <span class="o">=</span> <span class="n">chroma_stft</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># Generate Transformation matrix</span>
    <span class="n">n_chroma</span> <span class="o">=</span> <span class="n">chroma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">dim_map</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">n_chroma</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Interval scaling factors</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">7.0</span> <span class="o">/</span> <span class="mi">6</span><span class="p">,</span> <span class="mf">7.0</span> <span class="o">/</span> <span class="mi">6</span><span class="p">,</span> <span class="mf">3.0</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="mi">3</span><span class="p">])</span>

    <span class="c1"># Create the transformation matrix</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">scale</span><span class="p">[:,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">dim_map</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Even rows compute sin() offset</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">at</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="c1"># Radii for each dimension</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>  <span class="c1"># Fifths, Minor, Major</span>

    <span class="c1"># Compute the projection matrix</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">R</span><span class="p">[:,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">V</span><span class="p">)</span>

    <span class="c1"># Normalize chroma features</span>
    <span class="n">chroma_norm</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">chroma</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Do the transform to tonnetz</span>
    <span class="c1"># phi shape: (6, n_chroma)</span>
    <span class="c1"># chroma_norm shape: (..., n_chroma, t)</span>
    <span class="c1"># tonnetz shape: (..., 6, t)</span>
    <span class="n">tonnetz</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;pc,...ct-&gt;...pt&quot;</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">chroma_norm</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tonnetz</span></div>



<div class="viewcode-block" id="chroma_stft">
<a class="viewcode-back" href="../../../generated/librosax.feature.chroma_stft.html#librosax.feature.chroma_stft">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">chroma_stft</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">22050</span><span class="p">,</span>
    <span class="n">S</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
    <span class="n">win_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">tuning</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_chroma</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute a chromagram from a power spectrogram or waveform.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: Audio time series. The last axis must be time.</span>

<span class="sd">            - ``(T,)`` - single waveform</span>
<span class="sd">            - ``(B, T)`` - batch of waveforms</span>

<span class="sd">        sr: Sampling rate</span>
<span class="sd">        S: Power spectrogram with shape ``(..., F, N)`` (optional if y is provided)</span>
<span class="sd">        norm: Column-wise normalization. See `normalize` for details.</span>
<span class="sd">        n_fft: FFT window size</span>
<span class="sd">        hop_length: Hop length</span>
<span class="sd">        win_length: Window length</span>
<span class="sd">        window: Window specification</span>
<span class="sd">        center: Center the frames</span>
<span class="sd">        pad_mode: Padding mode</span>
<span class="sd">        tuning: Tuning deviation from A440 in fractional bins.</span>
<span class="sd">            If None, tuning will be automatically estimated (not implemented yet).</span>
<span class="sd">        n_chroma: Number of chroma bins to produce</span>
<span class="sd">        **kwargs: Additional arguments to chroma_filter (ctroct, octwidth, norm, base_c)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Chromagram with shape ``(..., n_chroma, N)``.</span>

<span class="sd">        - ``(T,)`` → ``(n_chroma, N)``</span>
<span class="sd">        - ``(B, T)`` → ``(B, n_chroma, N)``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get power spectrogram</span>
    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># _spectrogram returns magnitude, but chroma needs power</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">S</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="c1"># Estimate tuning if not provided</span>
    <span class="k">if</span> <span class="n">tuning</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_estimate_tuning</span><span class="p">(</span><span class="n">S_arr</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">librosa</span><span class="o">.</span><span class="n">estimate_tuning</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S_arr</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">bins_per_octave</span><span class="o">=</span><span class="n">n_chroma</span><span class="p">)])</span>
        <span class="n">tuning</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">pure_callback</span><span class="p">(</span>
            <span class="n">_estimate_tuning</span><span class="p">,</span>
            <span class="n">jax</span><span class="o">.</span><span class="n">ShapeDtypeStruct</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
            <span class="n">S</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Get the filter bank</span>
    <span class="n">chromafb</span> <span class="o">=</span> <span class="n">chroma_filter</span><span class="p">(</span>
        <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">tuning</span><span class="o">=</span><span class="n">tuning</span><span class="p">,</span>
        <span class="n">n_chroma</span><span class="o">=</span><span class="n">n_chroma</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>

    <span class="c1"># Apply the filter bank</span>
    <span class="c1"># chromafb shape: (n_chroma, 1 + n_fft/2)</span>
    <span class="c1"># S shape: (..., 1 + n_fft/2, t)</span>
    <span class="c1"># Use einsum for flexible dimensions</span>
    <span class="n">raw_chroma</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...ft,cf-&gt;...ct&quot;</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">chromafb</span><span class="p">)</span>

    <span class="c1"># Normalize</span>
    <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">chroma</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">raw_chroma</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">chroma</span> <span class="o">=</span> <span class="n">raw_chroma</span>

    <span class="k">return</span> <span class="n">chroma</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">poly_features</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">22050</span><span class="p">,</span>
    <span class="n">S</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
    <span class="n">win_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">center</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get coefficients of fitting an nth-order polynomial to the columns of a spectrogram.</span>

<span class="sd">    This function wraps librosa.feature.poly_features for compatibility.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: Audio time series.</span>
<span class="sd">        sr: Audio sampling rate of y.</span>
<span class="sd">        S: Spectrogram magnitude. If None, compute from y.</span>
<span class="sd">        n_fft: FFT window size.</span>
<span class="sd">        hop_length: Hop length for STFT.</span>
<span class="sd">        win_length: Window length. If None, defaults to n_fft.</span>
<span class="sd">        window: Window function.</span>
<span class="sd">        center: If True, center frames.</span>
<span class="sd">        pad_mode: Padding mode.</span>
<span class="sd">        order: Order of the polynomial (1=linear, 2=quadratic, etc).</span>
<span class="sd">        freq: Optional center frequencies for each row of S. If None, use FFT bin frequencies.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Polynomial coefficients with shape (..., order+1, t).</span>

<span class="sd">    Examples:</span>
<span class="sd">        Compute first-order (linear) coefficients</span>

<span class="sd">        &gt;&gt;&gt; y, sr = librosax.load(&#39;audio.wav&#39;)</span>
<span class="sd">        &gt;&gt;&gt; coeffs = librosax.feature.poly_features(y=y, sr=sr, order=1)</span>
<span class="sd">        &gt;&gt;&gt; coeffs.shape</span>
<span class="sd">        (2, t)  # intercept and slope for each frame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert JAX arrays to numpy if needed</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">poly_features</span><span class="p">(</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
        <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
        <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">chroma_vqt</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">22050</span><span class="p">,</span>
    <span class="n">V</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
    <span class="n">fmin</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">intervals</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ji5&quot;</span><span class="p">,</span>
    <span class="n">norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
    <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">n_octaves</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
    <span class="n">bins_per_octave</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
    <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Chromagram using Variable-Q Transform (VQT).</span>

<span class="sd">    This is a wrapper around librosa.feature.chroma_vqt for compatibility.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: Audio time series.</span>
<span class="sd">        sr: Sampling rate.</span>
<span class="sd">        V: Pre-computed VQT spectrogram (optional).</span>
<span class="sd">        hop_length: Hop length for VQT.</span>
<span class="sd">        fmin: Minimum frequency. If None, defaults to C1.</span>
<span class="sd">        intervals: Interval specification (&#39;ji3&#39;, &#39;ji5&#39;, &#39;equal&#39;, etc).</span>
<span class="sd">        norm: Normalization type.</span>
<span class="sd">        threshold: Pre-normalization energy threshold.</span>
<span class="sd">        n_octaves: Number of octaves.</span>
<span class="sd">        bins_per_octave: Number of bins per octave in the VQT.</span>
<span class="sd">        gamma: Bandwidth offset for variable-Q filterbank.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Chromagram with shape (..., n_chroma, t).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; y, sr = librosax.load(&#39;audio.wav&#39;)</span>
<span class="sd">        &gt;&gt;&gt; chroma = librosax.feature.chroma_vqt(y=y, sr=sr)</span>
<span class="sd">        &gt;&gt;&gt; chroma.shape</span>
<span class="sd">        (12, t)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert JAX arrays to numpy if needed</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">V</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">chroma_vqt</span><span class="p">(</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
        <span class="n">V</span><span class="o">=</span><span class="n">V</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span>
        <span class="n">intervals</span><span class="o">=</span><span class="n">intervals</span><span class="p">,</span>
        <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
        <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
        <span class="n">n_octaves</span><span class="o">=</span><span class="n">n_octaves</span><span class="p">,</span>
        <span class="n">bins_per_octave</span><span class="o">=</span><span class="n">bins_per_octave</span><span class="p">,</span>
        <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">chroma_cens</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">22050</span><span class="p">,</span>
    <span class="n">C</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">hop_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
    <span class="n">fmin</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">tuning</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_chroma</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
    <span class="n">n_octaves</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
    <span class="n">bins_per_octave</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">36</span><span class="p">,</span>
    <span class="n">cqt_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;full&quot;</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">win_len_smooth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">41</span><span class="p">,</span>
    <span class="n">smoothing_window</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hann&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute Chroma Energy Normalized Statistics (CENS).</span>

<span class="sd">    This is a wrapper around librosa.feature.chroma_cens.</span>

<span class="sd">    CENS is a variant of chroma features with additional temporal smoothing</span>
<span class="sd">    and energy normalization.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: Audio time series.</span>
<span class="sd">        sr: Sampling rate.</span>
<span class="sd">        C: Pre-computed constant-Q chromagram.</span>
<span class="sd">        hop_length: Hop length.</span>
<span class="sd">        fmin: Minimum frequency. If None, defaults to C1.</span>
<span class="sd">        tuning: Tuning deviation from A440 in fractional bins.</span>
<span class="sd">        n_chroma: Number of chroma bins.</span>
<span class="sd">        n_octaves: Number of octaves.</span>
<span class="sd">        bins_per_octave: Number of bins per octave in the CQT.</span>
<span class="sd">        cqt_mode: CQT mode.</span>
<span class="sd">        window: Optional weighting window.</span>
<span class="sd">        norm: Normalization type.</span>
<span class="sd">        win_len_smooth: Length of temporal smoothing window.</span>
<span class="sd">        smoothing_window: Type of smoothing window.</span>

<span class="sd">    Returns:</span>
<span class="sd">        CENS chromagram with shape (..., n_chroma, t).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; y, sr = librosax.load(&#39;audio.wav&#39;)</span>
<span class="sd">        &gt;&gt;&gt; cens = librosax.feature.chroma_cens(y=y, sr=sr)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert JAX arrays to numpy if needed</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">chroma_cens</span><span class="p">(</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
        <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span>
        <span class="n">tuning</span><span class="o">=</span><span class="n">tuning</span><span class="p">,</span>
        <span class="n">n_chroma</span><span class="o">=</span><span class="n">n_chroma</span><span class="p">,</span>
        <span class="n">n_octaves</span><span class="o">=</span><span class="n">n_octaves</span><span class="p">,</span>
        <span class="n">bins_per_octave</span><span class="o">=</span><span class="n">bins_per_octave</span><span class="p">,</span>
        <span class="n">cqt_mode</span><span class="o">=</span><span class="n">cqt_mode</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
        <span class="n">win_len_smooth</span><span class="o">=</span><span class="n">win_len_smooth</span><span class="p">,</span>
        <span class="n">smoothing_window</span><span class="o">=</span><span class="n">smoothing_window</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2025, David Braun
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../../_static/documentation_options.js?v=360bc84d"></script>
    <script src="../../../_static/doctools.js?v=fd6eb6e6"></script>
    <script src="../../../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script src="../../../_static/scripts/furo.js?v=46bd48cc"></script>
    </body>
</html>